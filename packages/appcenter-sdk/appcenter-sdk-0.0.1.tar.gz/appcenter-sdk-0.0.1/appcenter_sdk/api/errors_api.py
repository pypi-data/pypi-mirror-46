# coding: utf-8

"""
    App Center Client

    Microsoft Visual Studio App Center API  # noqa: E501

    OpenAPI spec version: preview
    Contact: benedetto.abbenanti@gmail.com
    Project Repository: https://github.com/b3nab/appcenter-sdks
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from appcenter_sdk.api_client import ApiClient


class errorsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def Errors_ListSessionLogs(self, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ListSessionLogs  # noqa: E501

        Get session logs by error ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ListSessionLogs(errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string date: Date of data requested(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ListSessionLogs_with_http_info(errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ListSessionLogs_with_http_info(errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ListSessionLogs_with_http_info(self, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ListSessionLogs  # noqa: E501

        Get session logs by error ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ListSessionLogs_with_http_info(errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string date: Date of data requested(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorId', 'owner_name', 'app_name', 'date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ListSessionLogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ListSessionLogs`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ListSessionLogs`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ListSessionLogs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/sessionLogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorAttachmentText(self, errorId, attachmentId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachmentText  # noqa: E501

        Error attachment text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachmentText(errorId, attachmentId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string attachmentId: Error attachment id. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorAttachmentText_with_http_info(errorId, attachmentId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorAttachmentText_with_http_info(errorId, attachmentId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorAttachmentText_with_http_info(self, errorId, attachmentId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachmentText  # noqa: E501

        Error attachment text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachmentText_with_http_info(errorId, attachmentId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string attachmentId: Error attachment id. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorId', 'attachmentId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorAttachmentText" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorAttachmentText`")  # noqa: E501
        # verify the required parameter 'attachmentId' is set
        if ('attachmentId' not in params or
                params['attachmentId'] is None):
            raise ValueError("Missing the required parameter `attachmentId` when calling `Errors_ErrorAttachmentText`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorAttachmentText`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorAttachmentText`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'attachmentId' in params:
            path_params['attachmentId'] = params['attachmentId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/text', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorAttachmentLocation(self, errorId, attachmentId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachmentLocation  # noqa: E501

        Error attachment location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachmentLocation(errorId, attachmentId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string attachmentId: Error attachment id. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorAttachmentLocation_with_http_info(errorId, attachmentId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorAttachmentLocation_with_http_info(errorId, attachmentId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorAttachmentLocation_with_http_info(self, errorId, attachmentId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachmentLocation  # noqa: E501

        Error attachment location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachmentLocation_with_http_info(errorId, attachmentId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string attachmentId: Error attachment id. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorId', 'attachmentId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorAttachmentLocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorAttachmentLocation`")  # noqa: E501
        # verify the required parameter 'attachmentId' is set
        if ('attachmentId' not in params or
                params['attachmentId'] is None):
            raise ValueError("Missing the required parameter `attachmentId` when calling `Errors_ErrorAttachmentLocation`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorAttachmentLocation`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorAttachmentLocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'attachmentId' in params:
            path_params['attachmentId'] = params['attachmentId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/location', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorAttachments(self, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachments  # noqa: E501

        List error attachments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachments(errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorAttachments_with_http_info(errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorAttachments_with_http_info(errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorAttachments_with_http_info(self, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorAttachments  # noqa: E501

        List error attachments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorAttachments_with_http_info(errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorAttachments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorAttachments`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorAttachments`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorAttachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorSearch(self, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorSearch  # noqa: E501

        Errors list based on search parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorSearch(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string filter: A filter as specified in OData notation(optional)
        :param string q: A query string(optional)
        :param string order: It controls the order of sorting(optional)
        :param string sort: It controls the sort based on specified field(optional)
        :param integer $top: The maximum number of results to return(optional)
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorSearch_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorSearch_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorSearch_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorSearch  # noqa: E501

        Errors list based on search parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorSearch_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string filter: A filter as specified in OData notation(optional)
        :param string q: A query string(optional)
        :param string order: It controls the order of sorting(optional, default to )
        :param string sort: It controls the sort based on specified field(optional, default to )
        :param integer $top: The maximum number of results to return(optional, default to )
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'filter', 'q', 'order', 'sort', '$top', '$skip']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorSearch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorSearch`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorSearch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501
        if '$skip' in params:
            query_params.append(('$skip', params['$skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def errors_putRetentionSettings(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """  # noqa: E501

        Creates and updates the retention settings in days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.errors_putRetentionSettings(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The amount of days to keep the crashes for this application. retention_in_days is an enum value, can only be 28 or 90. (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.errors_putRetentionSettings_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.errors_putRetentionSettings_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def errors_putRetentionSettings_with_http_info(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """  # noqa: E501

        Creates and updates the retention settings in days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.errors_putRetentionSettings_with_http_info(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The amount of days to keep the crashes for this application. retention_in_days is an enum value, can only be 28 or 90. (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method errors_putRetentionSettings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `errors_putRetentionSettings`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `errors_putRetentionSettings`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `errors_putRetentionSettings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/retention_settings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def errors_getRetentionSettings(self, owner_name, app_name, **kwargs):  # noqa: E501
        """  # noqa: E501

        gets the retention settings in days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.errors_getRetentionSettings(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.errors_getRetentionSettings_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.errors_getRetentionSettings_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def errors_getRetentionSettings_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """  # noqa: E501

        gets the retention settings in days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.errors_getRetentionSettings_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method errors_getRetentionSettings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `errors_getRetentionSettings`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `errors_getRetentionSettings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/retention_settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorFreeDevicePercentages(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorFreeDevicePercentages  # noqa: E501

        Percentage of error-free devices by day in the time range based on the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror. API will return -1 if crash devices is greater than active devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorFreeDevicePercentages(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param array versions:(optional)
        :param string errorType: Type of error (handled vs unhandled), excluding All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorFreeDevicePercentages_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorFreeDevicePercentages_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorFreeDevicePercentages_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorFreeDevicePercentages  # noqa: E501

        Percentage of error-free devices by day in the time range based on the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror. API will return -1 if crash devices is greater than active devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorFreeDevicePercentages_with_http_info(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param array versions:(optional)
        :param string errorType: Type of error (handled vs unhandled), excluding All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'versions', 'errorType']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorFreeDevicePercentages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_ErrorFreeDevicePercentages`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorFreeDevicePercentages`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorFreeDevicePercentages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
        if 'errorType' in params:
            query_params.append(('errorType', params['errorType']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorfreeDevicePercentages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupErrorStackTrace(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupErrorStackTrace  # noqa: E501

        Gets the stack trace for the error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupErrorStackTrace(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupErrorStackTrace_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupErrorStackTrace_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupErrorStackTrace_with_http_info(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupErrorStackTrace  # noqa: E501

        Gets the stack trace for the error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupErrorStackTrace_with_http_info(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupErrorStackTrace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupErrorStackTrace`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupErrorStackTrace`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupErrorStackTrace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/stacktrace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupOperatingSystemCounts(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupOperatingSystemCounts  # noqa: E501

        Top OSes of the selected error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupOperatingSystemCounts(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupOperatingSystemCounts_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupOperatingSystemCounts_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupOperatingSystemCounts_with_http_info(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupOperatingSystemCounts  # noqa: E501

        Top OSes of the selected error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupOperatingSystemCounts_with_http_info(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional, default to )
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name', '$top']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupOperatingSystemCounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupOperatingSystemCounts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupOperatingSystemCounts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupOperatingSystemCounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/operatingSystems', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupModelCounts(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupModelCounts  # noqa: E501

        Top models of the selected error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupModelCounts(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupModelCounts_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupModelCounts_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupModelCounts_with_http_info(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupModelCounts  # noqa: E501

        Top models of the selected error group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupModelCounts_with_http_info(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional, default to )
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name', '$top']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupModelCounts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupModelCounts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupModelCounts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupModelCounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorStackTrace(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorStackTrace  # noqa: E501

        Error Stacktrace details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorStackTrace(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorStackTrace_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorStackTrace_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorStackTrace_with_http_info(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorStackTrace  # noqa: E501

        Error Stacktrace details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorStackTrace_with_http_info(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'errorId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorStackTrace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_ErrorStackTrace`")  # noqa: E501
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorStackTrace`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorStackTrace`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorStackTrace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/stacktrace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorLocation(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorLocation  # noqa: E501

        Error location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorLocation(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorLocation_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorLocation_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorLocation_with_http_info(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorLocation  # noqa: E501

        Error location.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorLocation_with_http_info(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'errorId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorLocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_ErrorLocation`")  # noqa: E501
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorLocation`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorLocation`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorLocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/location', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorDownload(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorDownload  # noqa: E501

        Download details for a specific error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorDownload(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string format: the format of the crash log(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorDownload_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorDownload_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorDownload_with_http_info(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorDownload  # noqa: E501

        Download details for a specific error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorDownload_with_http_info(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string format: the format of the crash log(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'errorId', 'owner_name', 'app_name', 'format']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorDownload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_ErrorDownload`")  # noqa: E501
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_ErrorDownload`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorDownload`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorDownload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GetErrorDetails(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GetErrorDetails  # noqa: E501

        Error details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GetErrorDetails(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GetErrorDetails_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GetErrorDetails_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GetErrorDetails_with_http_info(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GetErrorDetails  # noqa: E501

        Error details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GetErrorDetails_with_http_info(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'errorId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GetErrorDetails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GetErrorDetails`")  # noqa: E501
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_GetErrorDetails`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GetErrorDetails`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GetErrorDetails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_DeleteError(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_DeleteError  # noqa: E501

        Delete a specific error and related attachments and blobs for an app. Searchable data will not be deleted immediately and may take up to 30 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_DeleteError(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_DeleteError_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_DeleteError_with_http_info(errorGroupId, errorId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_DeleteError_with_http_info(self, errorGroupId, errorId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_DeleteError  # noqa: E501

        Delete a specific error and related attachments and blobs for an app. Searchable data will not be deleted immediately and may take up to 30 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_DeleteError_with_http_info(errorGroupId, errorId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string errorId: The id of the error (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'errorId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_DeleteError" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_DeleteError`")  # noqa: E501
        # verify the required parameter 'errorId' is set
        if ('errorId' not in params or
                params['errorId'] is None):
            raise ValueError("Missing the required parameter `errorId` when calling `Errors_DeleteError`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_DeleteError`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_DeleteError`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'errorId' in params:
            path_params['errorId'] = params['errorId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_LatestErrorDetails(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_LatestErrorDetails  # noqa: E501

        Latest error details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_LatestErrorDetails(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_LatestErrorDetails_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_LatestErrorDetails_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_LatestErrorDetails_with_http_info(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_LatestErrorDetails  # noqa: E501

        Latest error details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_LatestErrorDetails_with_http_info(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_LatestErrorDetails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_LatestErrorDetails`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_LatestErrorDetails`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_LatestErrorDetails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ListForGroup(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ListForGroup  # noqa: E501

        Get all errors for group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ListForGroup(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string model:(optional)
        :param string os:(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ListForGroup_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ListForGroup_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ListForGroup_with_http_info(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ListForGroup  # noqa: E501

        Get all errors for group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ListForGroup_with_http_info(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string model:(optional)
        :param string os:(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'start', 'owner_name', 'app_name', 'end', 'model', 'os']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ListForGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_ListForGroup`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_ListForGroup`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ListForGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ListForGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'model' in params:
            query_params.append(('model', params['model']))  # noqa: E501
        if 'os' in params:
            query_params.append(('os', params['os']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupErrorFreeDevicePercentages(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupErrorFreeDevicePercentages  # noqa: E501

        Percentage of error-free devices by day in the time range. Api will return -1 if crash devices is greater than active devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupErrorFreeDevicePercentages(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupErrorFreeDevicePercentages_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupErrorFreeDevicePercentages_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupErrorFreeDevicePercentages_with_http_info(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupErrorFreeDevicePercentages  # noqa: E501

        Percentage of error-free devices by day in the time range. Api will return -1 if crash devices is greater than active devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupErrorFreeDevicePercentages_with_http_info(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'start', 'owner_name', 'app_name', 'end']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupErrorFreeDevicePercentages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupErrorFreeDevicePercentages`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_GroupErrorFreeDevicePercentages`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupErrorFreeDevicePercentages`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupErrorFreeDevicePercentages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorfreeDevicePercentages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupCountsPerDay(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupCountsPerDay  # noqa: E501

        Count of errors by day in the time range of the selected error group with selected version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupCountsPerDay(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupCountsPerDay_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupCountsPerDay_with_http_info(errorGroupId, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupCountsPerDay_with_http_info(self, errorGroupId, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupCountsPerDay  # noqa: E501

        Count of errors by day in the time range of the selected error group with selected version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupCountsPerDay_with_http_info(errorGroupId, start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'start', 'owner_name', 'app_name', 'version', 'end']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupCountsPerDay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupCountsPerDay`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_GroupCountsPerDay`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupCountsPerDay`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupCountsPerDay`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorCountsPerDay', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupDetails(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupDetails  # noqa: E501

        Error group details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupDetails(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupDetails_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupDetails_with_http_info(errorGroupId, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupDetails_with_http_info(self, errorGroupId, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupDetails  # noqa: E501

        Error group details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupDetails_with_http_info(errorGroupId, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupDetails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_GroupDetails`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupDetails`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupDetails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_UpdateState(self, errorGroupId, owner_name, app_name, body, **kwargs):  # noqa: E501
        """Errors_UpdateState  # noqa: E501

        Update error group state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_UpdateState(errorGroupId, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The state of the error group (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_UpdateState_with_http_info(errorGroupId, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_UpdateState_with_http_info(errorGroupId, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def Errors_UpdateState_with_http_info(self, errorGroupId, owner_name, app_name, body, **kwargs):  # noqa: E501
        """Errors_UpdateState  # noqa: E501

        Update error group state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_UpdateState_with_http_info(errorGroupId, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string errorGroupId: The id of the error group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The state of the error group (required)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['errorGroupId', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_UpdateState" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'errorGroupId' is set
        if ('errorGroupId' not in params or
                params['errorGroupId'] is None):
            raise ValueError("Missing the required parameter `errorGroupId` when calling `Errors_UpdateState`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_UpdateState`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_UpdateState`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `Errors_UpdateState`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'errorGroupId' in params:
            path_params['errorGroupId'] = params['errorGroupId']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_ErrorGroupsSearch(self, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorGroupsSearch  # noqa: E501

        Error groups list based on search parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorGroupsSearch(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string filter: A filter as specified in OData notation(optional)
        :param string q: A query string(optional)
        :param string order: It controls the order of sorting(optional)
        :param string sort: It controls the sort based on specified field(optional)
        :param integer $top: The maximum number of results to return(optional)
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_ErrorGroupsSearch_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_ErrorGroupsSearch_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_ErrorGroupsSearch_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_ErrorGroupsSearch  # noqa: E501

        Error groups list based on search parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_ErrorGroupsSearch_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string filter: A filter as specified in OData notation(optional)
        :param string q: A query string(optional)
        :param string order: It controls the order of sorting(optional, default to )
        :param string sort: It controls the sort based on specified field(optional, default to )
        :param integer $top: The maximum number of results to return(optional, default to )
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'filter', 'q', 'order', 'sort', '$top', '$skip']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_ErrorGroupsSearch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_ErrorGroupsSearch`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_ErrorGroupsSearch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501
        if '$skip' in params:
            query_params.append(('$skip', params['$skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_GroupList(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupList  # noqa: E501

        List of error groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupList(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string groupState:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string $orderby: controls the sorting order and sorting based on which column(optional)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional)
        :param string errorType: Type of error (handled vs unhandled), including All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_GroupList_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_GroupList_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_GroupList_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_GroupList  # noqa: E501

        List of error groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_GroupList_with_http_info(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string groupState:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string $orderby: controls the sorting order and sorting based on which column(optional, default to )
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional, default to )
        :param string errorType: Type of error (handled vs unhandled), including All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'version', 'groupState', 'end', '$orderby', '$top', 'errorType']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_GroupList" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_GroupList`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_GroupList`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_GroupList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'groupState' in params:
            query_params.append(('groupState', params['groupState']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if '$orderby' in params:
            query_params.append(('$orderby', params['$orderby']))  # noqa: E501
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501
        if 'errorType' in params:
            query_params.append(('errorType', params['errorType']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_CountsPerDay(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_CountsPerDay  # noqa: E501

        Count of crashes or errors by day in the time range based the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_CountsPerDay(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string errorType: Type of error (handled vs unhandled), excluding All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_CountsPerDay_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_CountsPerDay_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_CountsPerDay_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_CountsPerDay  # noqa: E501

        Count of crashes or errors by day in the time range based the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_CountsPerDay_with_http_info(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string version:(optional)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param string errorType: Type of error (handled vs unhandled), excluding All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'version', 'end', 'errorType']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_CountsPerDay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_CountsPerDay`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_CountsPerDay`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_CountsPerDay`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'errorType' in params:
            query_params.append(('errorType', params['errorType']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/errorCountsPerDay', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Errors_AvailableVersions(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_AvailableVersions  # noqa: E501

        Get all available versions in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_AvailableVersions(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional)
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :param string $filter: A filter as specified in https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#97-filtering.(optional)
        :param string $inlinecount: Controls whether or not to include a count of all the items across all pages.(optional)
        :param string errorType: Type of error (handled vs unhandled), including All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.Errors_AvailableVersions_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.Errors_AvailableVersions_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def Errors_AvailableVersions_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Errors_AvailableVersions  # noqa: E501

        Get all available versions in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.Errors_AvailableVersions_with_http_info(start, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string start: Start date time in data in ISO 8601 date time format (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string end: Last date time in data in ISO 8601 date time format(optional)
        :param integer $top: The maximum number of results to return. (0 will fetch all results till the max number.)(optional, default to )
        :param integer $skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.(optional)
        :param string $filter: A filter as specified in https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#97-filtering.(optional)
        :param string $inlinecount: Controls whether or not to include a count of all the items across all pages.(optional, default to )
        :param string errorType: Type of error (handled vs unhandled), including All(optional)
        :return: ErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', '$top', '$skip', '$filter', '$inlinecount', 'errorType']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Errors_AvailableVersions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `Errors_AvailableVersions`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `Errors_AvailableVersions`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `Errors_AvailableVersions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if '$top' in params:
            query_params.append(('$top', params['$top']))  # noqa: E501
        if '$skip' in params:
            query_params.append(('$skip', params['$skip']))  # noqa: E501
        if '$filter' in params:
            query_params.append(('$filter', params['$filter']))  # noqa: E501
        if '$inlinecount' in params:
            query_params.append(('$inlinecount', params['$inlinecount']))  # noqa: E501
        if 'errorType' in params:
            query_params.append(('errorType', params['errorType']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/errors/available_versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
