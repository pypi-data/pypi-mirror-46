# coding: utf-8

"""
    App Center Client

    Microsoft Visual Studio App Center API  # noqa: E501

    OpenAPI spec version: preview
    Contact: benedetto.abbenanti@gmail.com
    Project Repository: https://github.com/b3nab/appcenter-sdks
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from appcenter_sdk.api_client import ApiClient


class distributeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def devices_registerUserForDevice(self, user_id, body, **kwargs):  # noqa: E501
        """devices_registerUserForDevice  # noqa: E501

        Registers a user for an existing device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_registerUserForDevice(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string user_id: The ID of the user (required)
        :param object body: The device info. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_registerUserForDevice_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_registerUserForDevice_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def devices_registerUserForDevice_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """devices_registerUserForDevice  # noqa: E501

        Registers a user for an existing device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_registerUserForDevice_with_http_info(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string user_id: The ID of the user (required)
        :param object body: The device info. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_registerUserForDevice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `devices_registerUserForDevice`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `devices_registerUserForDevice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/users/{user_id}/devices/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_deviceDetails(self, device_udid, **kwargs):  # noqa: E501
        """devices_deviceDetails  # noqa: E501

        Returns the device details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_deviceDetails(device_udid, async=True)
        >>> result = thread.get()

        :param async bool
        :param string device_udid: The UDID of the device (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_deviceDetails_with_http_info(device_udid, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_deviceDetails_with_http_info(device_udid, **kwargs)  # noqa: E501
            return data

    def devices_deviceDetails_with_http_info(self, device_udid, **kwargs):  # noqa: E501
        """devices_deviceDetails  # noqa: E501

        Returns the device details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_deviceDetails_with_http_info(device_udid, async=True)
        >>> result = thread.get()

        :param async bool
        :param string device_udid: The UDID of the device (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_udid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_deviceDetails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_udid' is set
        if ('device_udid' not in params or
                params['device_udid'] is None):
            raise ValueError("Missing the required parameter `device_udid` when calling `devices_deviceDetails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_udid' in params:
            path_params['device_udid'] = params['device_udid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices/{device_udid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_removeUserDevice(self, device_udid, **kwargs):  # noqa: E501
        """devices_removeUserDevice  # noqa: E501

        Removes an existing device from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_removeUserDevice(device_udid, async=True)
        >>> result = thread.get()

        :param async bool
        :param string device_udid: The UDID of the device (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_removeUserDevice_with_http_info(device_udid, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_removeUserDevice_with_http_info(device_udid, **kwargs)  # noqa: E501
            return data

    def devices_removeUserDevice_with_http_info(self, device_udid, **kwargs):  # noqa: E501
        """devices_removeUserDevice  # noqa: E501

        Removes an existing device from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_removeUserDevice_with_http_info(device_udid, async=True)
        >>> result = thread.get()

        :param async bool
        :param string device_udid: The UDID of the device (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_udid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_removeUserDevice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_udid' is set
        if ('device_udid' not in params or
                params['device_udid'] is None):
            raise ValueError("Missing the required parameter `device_udid` when calling `devices_removeUserDevice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_udid' in params:
            path_params['device_udid'] = params['device_udid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices/{device_udid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_userDevicesList(self, **kwargs):  # noqa: E501
        """devices_userDevicesList  # noqa: E501

        Returns all devices associated with the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_userDevicesList(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_userDevicesList_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.devices_userDevicesList_with_http_info(**kwargs)  # noqa: E501
            return data

    def devices_userDevicesList_with_http_info(self, **kwargs):  # noqa: E501
        """devices_userDevicesList  # noqa: E501

        Returns all devices associated with the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_userDevicesList_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_userDevicesList" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_listTesterApps(self, **kwargs):  # noqa: E501
        """releases_listTesterApps  # noqa: E501

        Return a list of applications that the user has tester permission to with the latest release for each.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listTesterApps(async=True)
        >>> result = thread.get()

        :param async bool
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_listTesterApps_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.releases_listTesterApps_with_http_info(**kwargs)  # noqa: E501
            return data

    def releases_listTesterApps_with_http_info(self, **kwargs):  # noqa: E501
        """releases_listTesterApps  # noqa: E501

        Return a list of applications that the user has tester permission to with the latest release for each.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listTesterApps_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_listTesterApps" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/tester/apps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_getLatestByHash(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_getLatestByHash  # noqa: E501

        Get a release with hash 'release_hash' or the 'latest' from all the distribution groups assigned to the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByHash(app_secret, release_hash, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_secret: The secret of the target application (required)
        :param string release_hash: The hash of the release or 'latest' to get the latest release from all the distribution groups assigned to the current user. (required)
        :param string udid: When passing `udid` in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_getLatestByHash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_getLatestByHash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
            return data

    def releases_getLatestByHash_with_http_info(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_getLatestByHash  # noqa: E501

        Get a release with hash 'release_hash' or the 'latest' from all the distribution groups assigned to the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByHash_with_http_info(app_secret, release_hash, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_secret: The secret of the target application (required)
        :param string release_hash: The hash of the release or 'latest' to get the latest release from all the distribution groups assigned to the current user. (required)
        :param string udid: When passing `udid` in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_secret', 'release_hash', 'udid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_getLatestByHash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_secret' is set
        if ('app_secret' not in params or
                params['app_secret'] is None):
            raise ValueError("Missing the required parameter `app_secret` when calling `releases_getLatestByHash`")  # noqa: E501
        # verify the required parameter 'release_hash' is set
        if ('release_hash' not in params or
                params['release_hash'] is None):
            raise ValueError("Missing the required parameter `release_hash` when calling `releases_getLatestByHash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_secret' in params:
            path_params['app_secret'] = params['app_secret']  # noqa: E501
        if 'release_hash' in params:
            path_params['release_hash'] = params['release_hash']  # noqa: E501

        query_params = []
        if 'udid' in params:
            query_params.append(('udid', params['udid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/sdk/apps/{app_secret}/releases/{release_hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_getLatestByPublicDistributionGroup(self, app_secret, distribution_group_id, **kwargs):  # noqa: E501
        """releases_getLatestByPublicDistributionGroup  # noqa: E501

        Get a release with 'latest' for the given public group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByPublicDistributionGroup(app_secret, distribution_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_secret: The secret of the target application (required)
        :param string distribution_group_id: the id for destination (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_getLatestByPublicDistributionGroup_with_http_info(app_secret, distribution_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_getLatestByPublicDistributionGroup_with_http_info(app_secret, distribution_group_id, **kwargs)  # noqa: E501
            return data

    def releases_getLatestByPublicDistributionGroup_with_http_info(self, app_secret, distribution_group_id, **kwargs):  # noqa: E501
        """releases_getLatestByPublicDistributionGroup  # noqa: E501

        Get a release with 'latest' for the given public group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByPublicDistributionGroup_with_http_info(app_secret, distribution_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_secret: The secret of the target application (required)
        :param string distribution_group_id: the id for destination (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_secret', 'distribution_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_getLatestByPublicDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_secret' is set
        if ('app_secret' not in params or
                params['app_secret'] is None):
            raise ValueError("Missing the required parameter `app_secret` when calling `releases_getLatestByPublicDistributionGroup`")  # noqa: E501
        # verify the required parameter 'distribution_group_id' is set
        if ('distribution_group_id' not in params or
                params['distribution_group_id'] is None):
            raise ValueError("Missing the required parameter `distribution_group_id` when calling `releases_getLatestByPublicDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_secret' in params:
            path_params['app_secret'] = params['app_secret']  # noqa: E501
        if 'distribution_group_id' in params:
            path_params['distribution_group_id'] = params['distribution_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distibutionReleases_installAnalytics(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """distibutionReleases_installAnalytics  # noqa: E501

        Notify download(s) for the provided distribution release(s).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distibutionReleases_installAnalytics(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param object body: The install analytics request payload (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distibutionReleases_installAnalytics_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.distibutionReleases_installAnalytics_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def distibutionReleases_installAnalytics_with_http_info(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """distibutionReleases_installAnalytics  # noqa: E501

        Notify download(s) for the provided distribution release(s).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distibutionReleases_installAnalytics_with_http_info(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param object body: The install analytics request payload (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distibutionReleases_installAnalytics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `distibutionReleases_installAnalytics`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `distibutionReleases_installAnalytics`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `distibutionReleases_installAnalytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/csv', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/apps/{owner_name}/{app_name}/install_analytics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_getIosManifest(self, app_id, release_id, token, **kwargs):  # noqa: E501
        """releases_getIosManifest  # noqa: E501

        Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getIosManifest(app_id, release_id, token, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_id: The ID of the application (required)
        :param integer release_id: The release_id (required)
        :param string token: A hash that authorizes the download if it matches the release info. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_getIosManifest_with_http_info(app_id, release_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_getIosManifest_with_http_info(app_id, release_id, token, **kwargs)  # noqa: E501
            return data

    def releases_getIosManifest_with_http_info(self, app_id, release_id, token, **kwargs):  # noqa: E501
        """releases_getIosManifest  # noqa: E501

        Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getIosManifest_with_http_info(app_id, release_id, token, async=True)
        >>> result = thread.get()

        :param async bool
        :param string app_id: The ID of the application (required)
        :param integer release_id: The release_id (required)
        :param string token: A hash that authorizes the download if it matches the release info. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'release_id', 'token']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_getIosManifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `releases_getIosManifest`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_getIosManifest`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `releases_getIosManifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['app_id'] = params['app_id']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeNotifications_getNotificationByAppId(self, owner_name, app_name, **kwargs):  # noqa: E501
        """storeNotifications_getNotificationByAppId  # noqa: E501

        Application specific store service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeNotifications_getNotificationByAppId(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeNotifications_getNotificationByAppId_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeNotifications_getNotificationByAppId_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeNotifications_getNotificationByAppId_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """storeNotifications_getNotificationByAppId  # noqa: E501

        Application specific store service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeNotifications_getNotificationByAppId_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeNotifications_getNotificationByAppId" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeNotifications_getNotificationByAppId`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeNotifications_getNotificationByAppId`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/store_service_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_getReleaseUpdateDevicesStatus(self, release_id, resign_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_getReleaseUpdateDevicesStatus  # noqa: E501

        Returns the resign status to the caller  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_getReleaseUpdateDevicesStatus(release_id, resign_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string release_id: The ID of the release. (required)
        :param string resign_id: The ID of the resign operation. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean include_provisioning_profile: A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is 'complete' or 'preparing_for_testers'.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_getReleaseUpdateDevicesStatus_with_http_info(release_id, resign_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_getReleaseUpdateDevicesStatus_with_http_info(release_id, resign_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_getReleaseUpdateDevicesStatus_with_http_info(self, release_id, resign_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_getReleaseUpdateDevicesStatus  # noqa: E501

        Returns the resign status to the caller  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_getReleaseUpdateDevicesStatus_with_http_info(release_id, resign_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string release_id: The ID of the release. (required)
        :param string resign_id: The ID of the resign operation. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean include_provisioning_profile: A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is 'complete' or 'preparing_for_testers'.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'resign_id', 'owner_name', 'app_name', 'include_provisioning_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_getReleaseUpdateDevicesStatus" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `devices_getReleaseUpdateDevicesStatus`")  # noqa: E501
        # verify the required parameter 'resign_id' is set
        if ('resign_id' not in params or
                params['resign_id'] is None):
            raise ValueError("Missing the required parameter `resign_id` when calling `devices_getReleaseUpdateDevicesStatus`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_getReleaseUpdateDevicesStatus`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_getReleaseUpdateDevicesStatus`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'resign_id' in params:
            path_params['resign_id'] = params['resign_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'include_provisioning_profile' in params:
            query_params.append(('include_provisioning_profile', params['include_provisioning_profile']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_putDistributionTester(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_putDistributionTester  # noqa: E501

        Update details about the specified tester associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_putDistributionTester(release_id, tester_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string tester_id: The id of the tester (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body:(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_putDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_putDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_putDistributionTester_with_http_info(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_putDistributionTester  # noqa: E501

        Update details about the specified tester associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_putDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string tester_id: The id of the tester (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body:(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'tester_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_putDistributionTester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_putDistributionTester`")  # noqa: E501
        # verify the required parameter 'tester_id' is set
        if ('tester_id' not in params or
                params['tester_id'] is None):
            raise ValueError("Missing the required parameter `tester_id` when calling `releases_putDistributionTester`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_putDistributionTester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_putDistributionTester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'tester_id' in params:
            path_params['tester_id'] = params['tester_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_deleteDistributionTester(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionTester  # noqa: E501

        Delete the given tester from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionTester(release_id, tester_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string tester_id: The id of the tester (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_deleteDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_deleteDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_deleteDistributionTester_with_http_info(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionTester  # noqa: E501

        Delete the given tester from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionTester_with_http_info(release_id, tester_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string tester_id: The id of the tester (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'tester_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_deleteDistributionTester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_deleteDistributionTester`")  # noqa: E501
        # verify the required parameter 'tester_id' is set
        if ('tester_id' not in params or
                params['tester_id'] is None):
            raise ValueError("Missing the required parameter `tester_id` when calling `releases_deleteDistributionTester`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_deleteDistributionTester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_deleteDistributionTester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'tester_id' in params:
            path_params['tester_id'] = params['tester_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_addTesters(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addTesters  # noqa: E501

        Distributes a release to a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addTesters(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_addTesters_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_addTesters_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releases_addTesters_with_http_info(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addTesters  # noqa: E501

        Distributes a release to a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addTesters_with_http_info(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_addTesters" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_addTesters`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_addTesters`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_addTesters`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_addTesters`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_deleteDistributionStore(self, release_id, store_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionStore  # noqa: E501

        Delete the given distribution store from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionStore(release_id, store_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string store_id: The id of the distribution store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_deleteDistributionStore_with_http_info(release_id, store_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_deleteDistributionStore_with_http_info(release_id, store_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_deleteDistributionStore_with_http_info(self, release_id, store_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionStore  # noqa: E501

        Delete the given distribution store from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionStore_with_http_info(release_id, store_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string store_id: The id of the distribution store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'store_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_deleteDistributionStore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_deleteDistributionStore`")  # noqa: E501
        # verify the required parameter 'store_id' is set
        if ('store_id' not in params or
                params['store_id'] is None):
            raise ValueError("Missing the required parameter `store_id` when calling `releases_deleteDistributionStore`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_deleteDistributionStore`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_deleteDistributionStore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'store_id' in params:
            path_params['store_id'] = params['store_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_addStore(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addStore  # noqa: E501

        Distributes a release to a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addStore(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_addStore_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_addStore_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releases_addStore_with_http_info(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addStore  # noqa: E501

        Distributes a release to a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addStore_with_http_info(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_addStore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_addStore`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_addStore`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_addStore`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_addStore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def provisioning_profile(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """provisioning_profile  # noqa: E501

        Return information about the provisioning profile. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.provisioning_profile(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The release_id (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.provisioning_profile_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.provisioning_profile_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def provisioning_profile_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """provisioning_profile  # noqa: E501

        Return information about the provisioning profile. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.provisioning_profile_with_http_info(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The release_id (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method provisioning_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `provisioning_profile`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `provisioning_profile`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `provisioning_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_putDistributionGroup(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_putDistributionGroup  # noqa: E501

        Update details about the specified distribution group associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_putDistributionGroup(release_id, group_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string group_id: The id of the releases destination (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body:(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_putDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_putDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_putDistributionGroup_with_http_info(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_putDistributionGroup  # noqa: E501

        Update details about the specified distribution group associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_putDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string group_id: The id of the releases destination (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body:(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'group_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_putDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_putDistributionGroup`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `releases_putDistributionGroup`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_putDistributionGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_putDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_deleteDistributionGroup(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionGroup  # noqa: E501

        Delete the given distribution group from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionGroup(release_id, group_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string group_id: The id of the distribution group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_deleteDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_deleteDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_deleteDistributionGroup_with_http_info(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_deleteDistributionGroup  # noqa: E501

        Delete the given distribution group from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteDistributionGroup_with_http_info(release_id, group_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string group_id: The id of the distribution group (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'group_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_deleteDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_deleteDistributionGroup`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `releases_deleteDistributionGroup`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_deleteDistributionGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_deleteDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_addDistributionGroup(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addDistributionGroup  # noqa: E501

        Distributes a release to a group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addDistributionGroup(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_addDistributionGroup_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_addDistributionGroup_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releases_addDistributionGroup_with_http_info(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_addDistributionGroup  # noqa: E501

        Distributes a release to a group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_addDistributionGroup_with_http_info(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_addDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_addDistributionGroup`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_addDistributionGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_addDistributionGroup`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_addDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_getLatestByUser(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_getLatestByUser  # noqa: E501

        Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByUser(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string release_id: The ID of the release, or `latest` to get the latest release from all the distribution groups assigned to the current user. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string udid: when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_getLatestByUser_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_getLatestByUser_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_getLatestByUser_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_getLatestByUser  # noqa: E501

        Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByUser_with_http_info(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string release_id: The ID of the release, or `latest` to get the latest release from all the distribution groups assigned to the current user. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param string udid: when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'udid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_getLatestByUser" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_getLatestByUser`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_getLatestByUser`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_getLatestByUser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'udid' in params:
            query_params.append(('udid', params['udid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_updateDetails(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_updateDetails  # noqa: E501

        Update details of a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_updateDetails(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_updateDetails_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_updateDetails_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releases_updateDetails_with_http_info(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_updateDetails  # noqa: E501

        Update details of a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_updateDetails_with_http_info(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_updateDetails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_updateDetails`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_updateDetails`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_updateDetails`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_updateDetails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_update(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_update  # noqa: E501

        Updates a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_update(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_update_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_update_with_http_info(release_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releases_update_with_http_info(self, release_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releases_update  # noqa: E501

        Updates a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_update_with_http_info(release_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete  # noqa: E501

        Deletes a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_delete(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_delete_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete  # noqa: E501

        Deletes a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_delete_with_http_info(release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param integer release_id: The ID of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_availableToTester(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_availableToTester  # noqa: E501

        Return detailed information about releases avaiable to a tester.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_availableToTester(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean published_only: when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.(optional)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_availableToTester_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_availableToTester_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_availableToTester_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_availableToTester  # noqa: E501

        Return detailed information about releases avaiable to a tester.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_availableToTester_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean published_only: when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.(optional)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'published_only']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_availableToTester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_availableToTester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_availableToTester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'published_only' in params:
            query_params.append(('published_only', params['published_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_list(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list  # noqa: E501

        Return basic information about releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_list(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean published_only: When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.(optional)
        :param string scope: When the scope is 'tester', only includes releases that have been distributed to groups that the user belongs to.(optional)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_list_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list  # noqa: E501

        Return basic information about releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_list_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean published_only: When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.(optional)
        :param string scope: When the scope is 'tester', only includes releases that have been distributed to groups that the user belongs to.(optional)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'published_only', 'scope']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'published_only' in params:
            query_params.append(('published_only', params['published_only']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releaseUploads_complete(self, upload_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releaseUploads_complete  # noqa: E501

        Commits or aborts the upload process for a release for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releaseUploads_complete(upload_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string upload_id: The ID of the upload (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information (required)
        :return: ReleaseUploadEndResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releaseUploads_complete_with_http_info(upload_id, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releaseUploads_complete_with_http_info(upload_id, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releaseUploads_complete_with_http_info(self, upload_id, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releaseUploads_complete  # noqa: E501

        Commits or aborts the upload process for a release for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releaseUploads_complete_with_http_info(upload_id, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string upload_id: The ID of the upload (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information (required)
        :return: ReleaseUploadEndResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upload_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releaseUploads_complete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upload_id' is set
        if ('upload_id' not in params or
                params['upload_id'] is None):
            raise ValueError("Missing the required parameter `upload_id` when calling `releaseUploads_complete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releaseUploads_complete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releaseUploads_complete`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releaseUploads_complete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'upload_id' in params:
            path_params['upload_id'] = params['upload_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/release_uploads/{upload_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseUploadEndResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releaseUploads_create(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releaseUploads_create  # noqa: E501

        Begins the upload process for a new release for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releaseUploads_create(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information (required)
        :return: ReleaseUploadBeginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releaseUploads_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.releaseUploads_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def releaseUploads_create_with_http_info(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """releaseUploads_create  # noqa: E501

        Begins the upload process for a new release for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releaseUploads_create_with_http_info(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The release information (required)
        :return: ReleaseUploadBeginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releaseUploads_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releaseUploads_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releaseUploads_create`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releaseUploads_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/release_uploads', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseUploadBeginResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_listLatest(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_listLatest  # noqa: E501

        Get the latest release from every distribution group associated with an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listLatest(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_listLatest_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_listLatest_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_listLatest_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_listLatest  # noqa: E501

        Get the latest release from every distribution group associated with an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listLatest_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_listLatest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_listLatest`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_listLatest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/recent_releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_getRealTimeStatusByReleaseId(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getRealTimeStatusByReleaseId  # noqa: E501

        Return the Real time Status publishing of release from store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getRealTimeStatusByReleaseId(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param number release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_getRealTimeStatusByReleaseId_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_getRealTimeStatusByReleaseId_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_getRealTimeStatusByReleaseId_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getRealTimeStatusByReleaseId  # noqa: E501

        Return the Real time Status publishing of release from store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getRealTimeStatusByReleaseId_with_http_info(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param number release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_getRealTimeStatusByReleaseId" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_getRealTimeStatusByReleaseId`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `storeReleases_getRealTimeStatusByReleaseId`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_getRealTimeStatusByReleaseId`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_getRealTimeStatusByReleaseId`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleasePublishLogs_get(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleasePublishLogs_get  # noqa: E501

        Returns publish logs for a particular release published to a particular store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleasePublishLogs_get(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The ID of the realease (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleasePublishLogs_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleasePublishLogs_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleasePublishLogs_get_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleasePublishLogs_get  # noqa: E501

        Returns publish logs for a particular release published to a particular store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleasePublishLogs_get_with_http_info(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The ID of the realease (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleasePublishLogs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleasePublishLogs_get`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `storeReleasePublishLogs_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleasePublishLogs_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleasePublishLogs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_getPublishError(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getPublishError  # noqa: E501

        Return the Error Details of release which failed in publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getPublishError(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param number release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_getPublishError_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_getPublishError_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_getPublishError_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getPublishError  # noqa: E501

        Return the Error Details of release which failed in publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getPublishError_with_http_info(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param number release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_getPublishError" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_getPublishError`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `storeReleases_getPublishError`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_getPublishError`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_getPublishError`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_get(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_get  # noqa: E501

        Return releases published in a store for releaseId and storeId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_get(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_get_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_get  # noqa: E501

        Return releases published in a store for releaseId and storeId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_get_with_http_info(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_get`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `storeReleases_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_delete(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_delete  # noqa: E501

        delete the release with release Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_delete(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_delete_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_delete_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_delete_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_delete  # noqa: E501

        delete the release with release Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_delete_with_http_info(store_name, release_id, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string release_id: The id of the release (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_delete`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `storeReleases_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_list(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_list  # noqa: E501

        Return all releases published  in a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_list(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_list_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_list_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_list_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_list  # noqa: E501

        Return all releases published  in a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_list_with_http_info(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_list`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storeReleases_getLatest(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getLatest  # noqa: E501

        Returns the latest release published in a store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getLatest(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.storeReleases_getLatest_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storeReleases_getLatest_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def storeReleases_getLatest_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """storeReleases_getLatest  # noqa: E501

        Returns the latest release published in a store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.storeReleases_getLatest_with_http_info(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storeReleases_getLatest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `storeReleases_getLatest`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `storeReleases_getLatest`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `storeReleases_getLatest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_get(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_get  # noqa: E501

        Return the store details for specified store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_get(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stores_get_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_get_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_get_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_get  # noqa: E501

        Return the store details for specified store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_get_with_http_info(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_patch(self, store_name, owner_name, app_name, body, **kwargs):  # noqa: E501
        """stores_patch  # noqa: E501

        Update the store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_patch(store_name, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: Store update request (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stores_patch_with_http_info(store_name, owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_patch_with_http_info(store_name, owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def stores_patch_with_http_info(self, store_name, owner_name, app_name, body, **kwargs):  # noqa: E501
        """stores_patch  # noqa: E501

        Update the store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_patch_with_http_info(store_name, owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: Store update request (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stores_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_delete(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_delete  # noqa: E501

        delete the store based on specific store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_delete(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stores_delete_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_delete_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_delete_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_delete  # noqa: E501

        delete the store based on specific store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_delete_with_http_info(store_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string store_name: The name of the store (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_create(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """stores_create  # noqa: E501

        Create a new external store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_create(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The store request (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stores_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def stores_create_with_http_info(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """stores_create  # noqa: E501

        Create a new external store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_create_with_http_info(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The store request (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_create`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stores_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_list(self, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_list  # noqa: E501

        Get all the store details from Storage store table for a particular application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_list(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stores_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_list_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_list  # noqa: E501

        Get all the store details from Storage store table for a particular application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stores_list_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: array
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_getLatestByDistributionGroup(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_getLatestByDistributionGroup  # noqa: E501

        Return detailed information about a distributed release in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByDistributionGroup(owner_name, app_name, distribution_group_name, release_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string release_id: Only supports the constant `latest`, specific IDs are not supported. `latest` will return the latest release in the distribution group. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_getLatestByDistributionGroup_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_getLatestByDistributionGroup_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
            return data

    def releases_getLatestByDistributionGroup_with_http_info(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_getLatestByDistributionGroup  # noqa: E501

        Return detailed information about a distributed release in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_getLatestByDistributionGroup_with_http_info(owner_name, app_name, distribution_group_name, release_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string release_id: Only supports the constant `latest`, specific IDs are not supported. `latest` will return the latest release in the distribution group. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'distribution_group_name', 'release_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_getLatestByDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_getLatestByDistributionGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_getLatestByDistributionGroup`")  # noqa: E501
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_getLatestByDistributionGroup`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_getLatestByDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_deleteWithDistributionGroupId(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_deleteWithDistributionGroupId  # noqa: E501

        Deletes a release with id 'release_id' in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteWithDistributionGroupId(owner_name, app_name, distribution_group_name, release_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param string distribution_group_name: The name of the distribution group. (required)
        :param integer release_id: The ID identifying the unique release. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_deleteWithDistributionGroupId_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_deleteWithDistributionGroupId_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
            return data

    def releases_deleteWithDistributionGroupId_with_http_info(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_deleteWithDistributionGroupId  # noqa: E501

        Deletes a release with id 'release_id' in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_deleteWithDistributionGroupId_with_http_info(owner_name, app_name, distribution_group_name, release_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the app owner (required)
        :param string app_name: The name of the app (required)
        :param string distribution_group_name: The name of the distribution group. (required)
        :param integer release_id: The ID identifying the unique release. (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'distribution_group_name', 'release_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_deleteWithDistributionGroupId" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_deleteWithDistributionGroupId`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_deleteWithDistributionGroupId`")  # noqa: E501
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_deleteWithDistributionGroupId`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_deleteWithDistributionGroupId`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_listByDistributionGroup(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_listByDistributionGroup  # noqa: E501

        Return basic information about distributed releases in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listByDistributionGroup(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.releases_listByDistributionGroup_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_listByDistributionGroup_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_listByDistributionGroup_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_listByDistributionGroup  # noqa: E501

        Return basic information about distributed releases in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.releases_listByDistributionGroup_with_http_info(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_listByDistributionGroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_listByDistributionGroup`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_listByDistributionGroup`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_listByDistributionGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_listCsvFormat(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_listCsvFormat  # noqa: E501

        Returns all devices associated with the given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_listCsvFormat(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean unprovisioned_only: when true, filters out provisioned devices(optional)
        :param array udids: multiple UDIDs which should be part of the resulting CSV.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_listCsvFormat_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_listCsvFormat_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_listCsvFormat_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_listCsvFormat  # noqa: E501

        Returns all devices associated with the given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_listCsvFormat_with_http_info(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param boolean unprovisioned_only: when true, filters out provisioned devices(optional)
        :param array udids: multiple UDIDs which should be part of the resulting CSV.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name', 'unprovisioned_only', 'udids']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_listCsvFormat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `devices_listCsvFormat`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_listCsvFormat`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_listCsvFormat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'unprovisioned_only' in params:
            query_params.append(('unprovisioned_only', params['unprovisioned_only']))  # noqa: E501
        if 'udids' in params:
            query_params.append(('udids', params['udids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv', 'text/csv', 'text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_list(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list  # noqa: E501

        Returns all devices associated with the given distribution group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_list(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param number release_id: when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.devices_list_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_list_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_list_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list  # noqa: E501

        Returns all devices associated with the given distribution group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.devices_list_with_http_info(distribution_group_name, owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string distribution_group_name: The name of the distribution group. (required)
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param number release_id: when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release.(optional)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name', 'release_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `devices_list`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'release_id' in params:
            query_params.append(('release_id', params['release_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def appleMapping_TestFlightGroups(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_TestFlightGroups  # noqa: E501

        Fetch all apple test flight groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_TestFlightGroups(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.appleMapping_TestFlightGroups_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.appleMapping_TestFlightGroups_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def appleMapping_TestFlightGroups_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_TestFlightGroups  # noqa: E501

        Fetch all apple test flight groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_TestFlightGroups_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method appleMapping_TestFlightGroups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `appleMapping_TestFlightGroups`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `appleMapping_TestFlightGroups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def appleMapping_get(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_get  # noqa: E501

        Get mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_get(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.appleMapping_get_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.appleMapping_get_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def appleMapping_get_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_get  # noqa: E501

        Get mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_get_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method appleMapping_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `appleMapping_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `appleMapping_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def appleMapping_delete(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_delete  # noqa: E501

        Delete mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_delete(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.appleMapping_delete_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.appleMapping_delete_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def appleMapping_delete_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """appleMapping_delete  # noqa: E501

        Delete mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_delete_with_http_info(owner_name, app_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method appleMapping_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `appleMapping_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `appleMapping_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data', 'application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def appleMapping_create(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """appleMapping_create  # noqa: E501

        Create a mapping for an existing app in apple store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_create(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The apple app mapping object (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.appleMapping_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.appleMapping_create_with_http_info(owner_name, app_name, body, **kwargs)  # noqa: E501
            return data

    def appleMapping_create_with_http_info(self, owner_name, app_name, body, **kwargs):  # noqa: E501
        """appleMapping_create  # noqa: E501

        Create a mapping for an existing app in apple store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.appleMapping_create_with_http_info(owner_name, app_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param string owner_name: The name of the owner (required)
        :param string app_name: The name of the application (required)
        :param object body: The apple app mapping object (required)
        :return: ErrorDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method appleMapping_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `appleMapping_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `appleMapping_create`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `appleMapping_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ErrorDetails',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
