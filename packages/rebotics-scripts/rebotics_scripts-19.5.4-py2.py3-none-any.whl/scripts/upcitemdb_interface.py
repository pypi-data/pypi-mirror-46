"""
Script to retrieve the upcitemdb through multiple of random proxies for list of the UPC,
generated by rebotics retailer service.

Requires python 3.6 and asyncio module

basic usage:
    $ python3 upcitemdb_interface.py /path/to/upc_list /path/to/output.csv

where upc_list is the file containing list UPC numbers on each new line
    $ head upc_list
    123123123
    12312334
    123125465
    1231231235

and
    $ head output.csv
    label,image
    1231231,http://walmart.com/scrapped/image1.jpg
    1231231,http://walmart.com/scrapped/image2.jpg
    1231231,http://walmart.com/scrapped/image3.jpg


To generate the result as the input for this file run:
    $ docker-compose run --rm -v $(pwd):/tmp django python manage.py shell_plus

Then to retrieve the list of the upc that we need to collect
>>> from product.models import ProductUpcMap
>>> from django.db.models import Count
>>> pum = ProductUpcMap.objects.filter(upc__isnull=False).annotate(previews_count=Count('image_previews')).filter(previews_count=0).order_by('previews_count')
>>> with open('/tmp/upc_list', 'w') as fout:
...     for p in pum.values_list('upc', flat=True):
...         if p:
...             fout.write(p)
...             fout.write("\n")


Configuration for TOR interface.
1. Enable ControlPort on 9051 in /etc/tor/torrc
2. Create your password for ControlPort using tor --hash-password
    $ tor --hash-password <any password as string without spaces>
3. Put this password hash inside /etc/tor/torc under HashedControlPassword key
4. Restart tor:
    $ sudo service tor restart


Copyright (c) 2018 RetechLabs.com
"""
import asyncio
import csv
import random
import re
from collections import defaultdict

import ratelimit
import requests
from fake_useragent import UserAgent
from proxybroker import Broker

UPCITEMDB_UPC_POST_URL = 'https://api.upcitemdb.com/prod/trial/lookup'
UA = UserAgent()
PASSWORD = ''


def get_tor_session():
    from stem import Signal
    from stem.control import Controller

    global PASSWORD
    # signal TOR for a new connection
    with Controller.from_port(port=9051) as controller:
        controller.authenticate(password=PASSWORD)
        controller.signal(Signal.NEWNYM)

    session = requests.session()
    # Tor uses the 9050 port as the default socks port
    print('Starting new tor proxy session')
    session.proxies = {'http': 'socks5://127.0.0.1:9050',
                       'https': 'socks5://127.0.0.1:9050'}
    return session


class RateLimited(BaseException):
    pass


class ProxyTuple(object):
    def __init__(self, proto, host, port):
        self.proto = proto
        self.host = host
        self.port = port

    def __str__(self):
        return '{proto}://{host}:{port}'.format(
            proto=self.proto, host=self.host, port=self.port
        )

    def __repr__(self):
        return '<ProxyTuple %s>' % self.__str__()

    def to_request_proxy(self):
        return {
            self.proto: '{proto}://{host}:{port}'.format(
                proto=self.proto, host=self.host, port=self.port
            )
        }


def get_proxies(limit=10):
    proxy_list = []

    async def show(proxies):
        while True:
            proxy = await proxies.get()
            if proxy is None:
                break
            proto = 'https' if 'HTTPS' in proxy.types else 'http'
            proxy_list.append(ProxyTuple(proto, proxy.host, proxy.port))

    proxies = asyncio.Queue()
    broker = Broker(proxies)

    tasks = asyncio.gather(
        broker.find(types=['HTTPS'], limit=limit),
        show(proxies)
    )

    loop = asyncio.get_event_loop()
    loop.run_until_complete(tasks)

    print('Found: {} proxies'.format(len(proxy_list)))

    return proxy_list


def get_batches(upc_list, limit=10):
    batches = []
    current_list = []

    for i, upc in enumerate(upc_list, start=1):
        current_list.append(upc)

        if i % limit == 0:
            batches.append(current_list)
            current_list = []

    # left-overs
    batches.append(current_list)
    return batches


@ratelimit.sleep_and_retry
@ratelimit.rate_limited(1, 11)
def do_api_call(session, url, batch):
    response = session.post(url, json={
        'upc': ','.join(batch)
    }, headers={
        'User-Agent': UA.random
    })
    if response.status_code == 429:
        if response.json()['code'] == 'EXCEED_LIMIT':
            raise RateLimited('Rate limited for the exit node, try to renew the exit IP address')
    if response.status_code == 404:
        print('Invalid query, not found: {}'.format(response.json()))
        return []
    if response.status_code == 500:
        print('Server error, trying again...')
    if response.status_code == 400:
        print('Ivalid query... {}'.format(response.json()))
        print('batch: [{}]'.format(batch))
        return []
    if response.status_code != 200:
        print(response.status_code)
        raise requests.RequestException(response.json()['message'])
    json_response = response.json()
    items = json_response['items']
    print("Result that we got from upcitemdb: {}".format(items))
    return items


def make_requests(batches):
    """
    Generator to make a bunch or requests
    :param batches:
    :return:
    """
    session = get_tor_session()
    url = UPCITEMDB_UPC_POST_URL

    for i, batch in enumerate(batches):
        print('Trying to get batch {} out of {}'.format(i, len(batches)))
        while True:
            # try until we have a proper result
            try:
                yield do_api_call(session, url, batch), batch
                break
            except ratelimit.RateLimitException:
                print('Got a limit exception for too many calls')
            except RateLimited as e:
                print('Got rate limiting for proxy, renew tor proxy, {}'.format(e))
                session = get_tor_session()
            except requests.RequestException as e:
                print('{} with proxy: {}'.format(e, session.proxies))


def main(filename_in, filename_out, processed_items_file):
    print('{}>>{}'.format(filename_in, filename_out))

    existing_result = defaultdict(list)
    pattern = re.compile(r'^\d+$')

    with open(filename_out, 'r') as result_csv:
        reader = csv.reader(result_csv)
        for i, row in enumerate(reader):
            label = row[0]
            image_url = row[1]
            existing_result[label].append(image_url)
    print('We have already data for {} UPC'.format(len(existing_result.keys())))

    with open(processed_items_file, 'a+') as fin:
        fin.seek(0)
        processed_items = [x.strip() for x in fin.readlines()]

    print('We have processed {} items'.format(len(processed_items)))

    with open(filename_in, 'r') as fin:
        fin.seek(0)
        upc_list = [x.strip() for x in fin.readlines()]

    print('Number of UPC to search is: {}'.format(len(upc_list)))
    upc_list = [x for x in upc_list if x not in existing_result.keys()]
    print('Number after getting from existing result keys: {}'.format(len(upc_list)))
    upc_list = [x for x in upc_list if x not in processed_items]
    print('Number after processed_items: {}'.format(len(upc_list)))
    upc_list = [x for x in upc_list if pattern.match(x)]
    print('Number after filtering by UPC format: {}'.format(len(upc_list)))
    # upc_list = [x for x in upc_list if upc.is_valid_upc(x)]
    # upc_list = list(filter(lambda x: not upc.is_valid_upc(x), upc_list))
    # print('Number after filtering by UPC validation: {}'.format(len(upc_list)))

    random.shuffle(upc_list)

    print('After filtering number of UPC to search is: {}'.format(len(upc_list)))
    batches = get_batches(upc_list, 10)

    for response_results, batch in make_requests(batches):

        print('Writing intermediate results to the file')
        with open(filename_out, 'a') as fout:
            fieldnames = ['label', 'image']
            writer = csv.DictWriter(fout, fieldnames=fieldnames)

            for result in response_results:
                label = result['upc']
                for image_url in result['images']:
                    writer.writerow({
                        'label': label,
                        'image': image_url
                    })
                else:
                    print('There are no preview images for {}'.format(label))

        with open(processed_items_file, 'a+') as fout:
            fout.writelines("\n".join(batch))
            processed_items += batch


if __name__ == '__main__':
    # global PASSWORD
    password = input('Tor password: ')

    PASSWORD = password

    print('Modify the input and output files')

    main('/home/malik/upc_list', '/home/malik/upc_out.csv', '/home/malik/processed.csv')
    # main(sys.argv[1], sys.argv[2], sys.argv[3])
