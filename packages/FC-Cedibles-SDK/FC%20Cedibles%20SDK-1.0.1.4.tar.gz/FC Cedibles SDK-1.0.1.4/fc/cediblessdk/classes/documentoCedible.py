#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Oct 22 10:48:26 2018 by generateDS.py version 2.29.24.
# Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 12:01:12)  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]
#
# Command line options:
#   ('-o', 'classes/documentoCedible.py')
#   ('-s', 'classes/documentoCedibleSubs.py')
#   ('--super', 'DocumentCedible')
#   ('-f', '')
#   ('--no-namespace-defs', '')
#
# Command line arguments:
#   schemas/DocumentoCedible_v10.xsd
#
# Command line:
#   /Users/josfh/virtualenvs/fc-cedibledocs-py27/bin/generateDS -o "classes/documentoCedible.py" -s "classes/documentoCedibleSubs.py" --super="DocumentCedible" -f --no-namespace-defs schemas/DocumentoCedible_v10.xsd
#
# Current working directory (os.getcwd()):
#   cediblessdk
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.2f' % input_data)
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class CdgTrasladoType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class CodRefType(object):
    _1='1'
    _2='2'
    _3='3'


class DOCType(object):
    _3_3='33'
    _3_4='34'
    _4_3='43'
    _4_6='46'
    _5_2='52'
    _5_6='56'
    _6_1='61'
    _1_10='110'
    _1_11='111'
    _1_12='112'


class DTEFacturasType(object):
    _3_3='33'
    _3_4='34'
    _4_6='46'
    _4_3='43'


class DTEType(object):
    _3_3='33'
    _3_4='34'
    _4_6='46'
    _5_2='52'
    _5_6='56'
    _6_1='61'


class DineroPorcentajeType(object):
    _='%'
    _='$'


class DocCedibleType(object):
    _8_01='801'
    _8_03='803'
    _8_05='805'
    _8_06='806'
    _9_01='901'
    _9_02='902'


class DocType(object):
    _3_3='33'
    _3_4='34'
    _4_6='46'
    _5_2='52'
    _5_6='56'
    _6_1='61'


class EXPType(object):
    _1_10='110'
    _1_11='111'
    _1_12='112'


class FmaPagoType(object):
    _1='1'
    _2='2'
    _3='3'


class ImpAdicDTEType(object):
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _1_8='18'
    _1_9='19'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _3_0='30'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_4='34'
    _3_5='35'
    _3_6='36'
    _3_7='37'
    _3_8='38'
    _3_9='39'
    _4_0='40'
    _4_1='41'
    _4_4='44'
    _4_5='45'
    _4_6='46'
    _4_7='47'
    _4_8='48'
    _4_9='49'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _5_4='54'
    _5_5='55'
    _2_71='271'
    _3_01='301'
    _3_21='321'
    _3_31='331'
    _3_41='341'
    _3_61='361'
    _3_71='371'
    _4_81='481'


class ImpAdicType(object):
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _1_8='18'
    _1_9='19'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _2_9='29'
    _3_0='30'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_4='34'
    _3_5='35'
    _3_6='36'
    _3_7='37'
    _3_8='38'
    _3_9='39'
    _4_0='40'
    _4_1='41'
    _4_4='44'
    _4_5='45'
    _4_6='46'
    _4_7='47'
    _4_8='48'
    _4_9='49'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _5_4='54'
    _5_5='55'
    _2_71='271'
    _3_01='301'
    _3_21='321'
    _3_31='331'
    _3_41='341'
    _3_61='361'
    _3_71='371'
    _4_81='481'


class IndAgenteType(object):
    R='R'


class IndExeDRType(object):
    _1='1'
    _2='2'


class IndExeType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'


class IndGlobalType(object):
    _1='1'


class IndNoRebajaType(object):
    _1='1'


class IndServicioType(object):
    _1='1'
    _2='2'
    _3='3'


class IndTrasladoType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'
    _8='8'
    _9='9'


class LIQType(object):
    _4_3='43'


class MedioPagoType(object):
    CH='CH'
    LT='LT'
    EF='EF'
    PE='PE'
    TC='TC'
    CF='CF'
    OT='OT'


class MntBrutoType(object):
    _1='1'


class TipMonType(object):
    BOLIVAR='BOLIVAR'
    BOLIVIANO='BOLIVIANO'
    CHELIN='CHELIN'
    CORONADIN='CORONA DIN'
    CORONANOR='CORONA NOR'
    CORONASC='CORONA SC'
    CRUZEIROREAL='CRUZEIRO REAL'
    DIRHAM='DIRHAM'
    DOLARAUST='DOLAR AUST'
    DOLARCAN='DOLAR CAN'
    DOLARHK='DOLAR HK'
    DOLARNZ='DOLAR NZ'
    DOLARSIN='DOLAR SIN'
    DOLARTAI='DOLAR TAI'
    DOLARUSA='DOLAR USA'
    DRACMA='DRACMA'
    ESCUDO='ESCUDO'
    EURO='EURO'
    FLORIN='FLORIN'
    FRANCOBEL='FRANCO BEL'
    FRANCOFR='FRANCO FR'
    FRANCOSZ='FRANCO SZ'
    GUARANI='GUARANI'
    LIBRAEST='LIBRA EST'
    LIRA='LIRA'
    MARCOAL='MARCO AL'
    MARCOFIN='MARCO FIN'
    NUEVOSOL='NUEVO SOL'
    OTRASMONEDAS='OTRAS MONEDAS'
    PESETA='PESETA'
    PESO='PESO'
    PESOCL='PESO CL'
    PESOCOL='PESO COL'
    PESOMEX='PESO MEX'
    PESOURUG='PESO URUG'
    RAND='RAND'
    RENMINBI='RENMINBI'
    RUPIA='RUPIA'
    SUCRE='SUCRE'
    YEN='YEN'


class TipoDespachoType(object):
    _1='1'
    _2='2'
    _3='3'


class TipoTransCOMPRA(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'


class TipoTransVENTA(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class TpoCtaPagoType(object):
    AHORRO='AHORRO'
    CORRIENTE='CORRIENTE'
    VISTA='VISTA'


class TpoImpresionType(object):
    N='N'
    T='T'


class TpoMovType(object):
    D='D'
    R='R'


class DocumentoCedible(GeneratedsSuper):
    """Documento Tributario Electronico Cedible"""
    subclass = None
    superclass = None
    def __init__(self, version=1.0, Documento=None, Signature=None):
        self.original_tagname_ = None
        self.version = _cast(float, version)
        self.Documento = Documento
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentoCedible)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentoCedible.subclass:
            return DocumentoCedible.subclass(*args_, **kwargs_)
        else:
            return DocumentoCedible(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documento(self): return self.Documento
    def set_Documento(self, Documento): self.Documento = Documento
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.Documento is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DocumentoCedible', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentoCedible')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentoCedible')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DocumentoCedible', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DocumentoCedible'):
        if self.version != 1.0 and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DocumentoCedible', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Documento is not None:
            self.Documento.export(outfile, level, namespaceprefix_, name_='Documento', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documento':
            obj_ = DocumentoType.factory()
            obj_.build(child_)
            self.Documento = obj_
            obj_.original_tagname_ = 'Documento'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class DocumentoCedible


class SignatureType(GeneratedsSuper):
    """Firma Digital con Restricciones"""
    subclass = None
    superclass = None
    def __init__(self, SignedInfo=None, SignatureValue=None, KeyInfo=None):
        self.original_tagname_ = None
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self): return self.SignedInfo
    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo
    def get_SignatureValue(self): return self.SignatureValue
    def set_SignatureValue(self, SignatureValue): self.SignatureValue = SignatureValue
    def get_KeyInfo(self): return self.KeyInfo
    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xmldsig:', name_='SignatureType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='xmldsig:', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xmldsig:', name_='SignatureType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='xmldsig:', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespaceprefix_, name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xmldsig:SignatureValue>%s</xmldsig:SignatureValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureValue), input_name='SignatureValue')), eol_))
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespaceprefix_, name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            SignatureValue_ = child_.text
            SignatureValue_ = self.gds_validate_string(SignatureValue_, node, 'SignatureValue')
            self.SignatureValue = SignatureValue_
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class DocumentoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Encabezado=None, Detalle=None, SubTotInfo=None, DscRcgGlobal=None, Referencia=None, TmstFirma=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Encabezado = Encabezado
        if Detalle is None:
            self.Detalle = []
        else:
            self.Detalle = Detalle
        if SubTotInfo is None:
            self.SubTotInfo = []
        else:
            self.SubTotInfo = SubTotInfo
        if DscRcgGlobal is None:
            self.DscRcgGlobal = []
        else:
            self.DscRcgGlobal = DscRcgGlobal
        if Referencia is None:
            self.Referencia = []
        else:
            self.Referencia = Referencia
        if isinstance(TmstFirma, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TmstFirma, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TmstFirma
        self.TmstFirma = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentoType.subclass:
            return DocumentoType.subclass(*args_, **kwargs_)
        else:
            return DocumentoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Encabezado(self): return self.Encabezado
    def set_Encabezado(self, Encabezado): self.Encabezado = Encabezado
    def get_Detalle(self): return self.Detalle
    def set_Detalle(self, Detalle): self.Detalle = Detalle
    def add_Detalle(self, value): self.Detalle.append(value)
    def insert_Detalle_at(self, index, value): self.Detalle.insert(index, value)
    def replace_Detalle_at(self, index, value): self.Detalle[index] = value
    def get_SubTotInfo(self): return self.SubTotInfo
    def set_SubTotInfo(self, SubTotInfo): self.SubTotInfo = SubTotInfo
    def add_SubTotInfo(self, value): self.SubTotInfo.append(value)
    def insert_SubTotInfo_at(self, index, value): self.SubTotInfo.insert(index, value)
    def replace_SubTotInfo_at(self, index, value): self.SubTotInfo[index] = value
    def get_DscRcgGlobal(self): return self.DscRcgGlobal
    def set_DscRcgGlobal(self, DscRcgGlobal): self.DscRcgGlobal = DscRcgGlobal
    def add_DscRcgGlobal(self, value): self.DscRcgGlobal.append(value)
    def insert_DscRcgGlobal_at(self, index, value): self.DscRcgGlobal.insert(index, value)
    def replace_DscRcgGlobal_at(self, index, value): self.DscRcgGlobal[index] = value
    def get_Referencia(self): return self.Referencia
    def set_Referencia(self, Referencia): self.Referencia = Referencia
    def add_Referencia(self, value): self.Referencia.append(value)
    def insert_Referencia_at(self, index, value): self.Referencia.insert(index, value)
    def replace_Referencia_at(self, index, value): self.Referencia[index] = value
    def get_TmstFirma(self): return self.TmstFirma
    def set_TmstFirma(self, TmstFirma): self.TmstFirma = TmstFirma
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_FechaHoraType(self, value):
        # Validate type FechaHoraType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_datetime('2000-01-01T00:00:00'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaHoraType' % {"value" : value} )
            if value > self.gds_parse_datetime('2050-12-31T23:59:59'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaHoraType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Encabezado is not None or
            self.Detalle or
            self.SubTotInfo or
            self.DscRcgGlobal or
            self.Referencia or
            self.TmstFirma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DocumentoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DocumentoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DocumentoType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DocumentoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Encabezado is not None:
            self.Encabezado.export(outfile, level, namespaceprefix_, name_='Encabezado', pretty_print=pretty_print)
        for Detalle_ in self.Detalle:
            Detalle_.export(outfile, level, namespaceprefix_, name_='Detalle', pretty_print=pretty_print)
        for SubTotInfo_ in self.SubTotInfo:
            SubTotInfo_.export(outfile, level, namespaceprefix_, name_='SubTotInfo', pretty_print=pretty_print)
        for DscRcgGlobal_ in self.DscRcgGlobal:
            DscRcgGlobal_.export(outfile, level, namespaceprefix_, name_='DscRcgGlobal', pretty_print=pretty_print)
        for Referencia_ in self.Referencia:
            Referencia_.export(outfile, level, namespaceprefix_, name_='Referencia', pretty_print=pretty_print)
        if self.TmstFirma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TmstFirma>%s</SiiDte:TmstFirma>%s' % (self.gds_format_datetime(self.TmstFirma, input_name='TmstFirma'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Encabezado':
            obj_ = EncabezadoType.factory()
            obj_.build(child_)
            self.Encabezado = obj_
            obj_.original_tagname_ = 'Encabezado'
        elif nodeName_ == 'Detalle':
            obj_ = DetalleType.factory()
            obj_.build(child_)
            self.Detalle.append(obj_)
            obj_.original_tagname_ = 'Detalle'
        elif nodeName_ == 'SubTotInfo':
            obj_ = SubTotInfoType.factory()
            obj_.build(child_)
            self.SubTotInfo.append(obj_)
            obj_.original_tagname_ = 'SubTotInfo'
        elif nodeName_ == 'DscRcgGlobal':
            obj_ = DscRcgGlobalType.factory()
            obj_.build(child_)
            self.DscRcgGlobal.append(obj_)
            obj_.original_tagname_ = 'DscRcgGlobal'
        elif nodeName_ == 'Referencia':
            obj_ = ReferenciaType.factory()
            obj_.build(child_)
            self.Referencia.append(obj_)
            obj_.original_tagname_ = 'Referencia'
        elif nodeName_ == 'TmstFirma':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.TmstFirma = dval_
            # validate type FechaHoraType
            self.validate_FechaHoraType(self.TmstFirma)
# end class DocumentoType


class EncabezadoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IdDoc=None, Emisor=None, Receptor=None, Totales=None, OtraMoneda=None):
        self.original_tagname_ = None
        self.IdDoc = IdDoc
        self.Emisor = Emisor
        self.Receptor = Receptor
        self.Totales = Totales
        self.OtraMoneda = OtraMoneda
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EncabezadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EncabezadoType.subclass:
            return EncabezadoType.subclass(*args_, **kwargs_)
        else:
            return EncabezadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdDoc(self): return self.IdDoc
    def set_IdDoc(self, IdDoc): self.IdDoc = IdDoc
    def get_Emisor(self): return self.Emisor
    def set_Emisor(self, Emisor): self.Emisor = Emisor
    def get_Receptor(self): return self.Receptor
    def set_Receptor(self, Receptor): self.Receptor = Receptor
    def get_Totales(self): return self.Totales
    def set_Totales(self, Totales): self.Totales = Totales
    def get_OtraMoneda(self): return self.OtraMoneda
    def set_OtraMoneda(self, OtraMoneda): self.OtraMoneda = OtraMoneda
    def hasContent_(self):
        if (
            self.IdDoc is not None or
            self.Emisor is not None or
            self.Receptor is not None or
            self.Totales is not None or
            self.OtraMoneda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='EncabezadoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EncabezadoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EncabezadoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='EncabezadoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='EncabezadoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='EncabezadoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IdDoc is not None:
            self.IdDoc.export(outfile, level, namespaceprefix_, name_='IdDoc', pretty_print=pretty_print)
        if self.Emisor is not None:
            self.Emisor.export(outfile, level, namespaceprefix_, name_='Emisor', pretty_print=pretty_print)
        if self.Receptor is not None:
            self.Receptor.export(outfile, level, namespaceprefix_, name_='Receptor', pretty_print=pretty_print)
        if self.Totales is not None:
            self.Totales.export(outfile, level, namespaceprefix_, name_='Totales', pretty_print=pretty_print)
        if self.OtraMoneda is not None:
            self.OtraMoneda.export(outfile, level, namespaceprefix_, name_='OtraMoneda', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdDoc':
            obj_ = IdDocType.factory()
            obj_.build(child_)
            self.IdDoc = obj_
            obj_.original_tagname_ = 'IdDoc'
        elif nodeName_ == 'Emisor':
            obj_ = EmisorType.factory()
            obj_.build(child_)
            self.Emisor = obj_
            obj_.original_tagname_ = 'Emisor'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType.factory()
            obj_.build(child_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Totales':
            obj_ = TotalesType.factory()
            obj_.build(child_)
            self.Totales = obj_
            obj_.original_tagname_ = 'Totales'
        elif nodeName_ == 'OtraMoneda':
            obj_ = OtraMonedaType.factory()
            obj_.build(child_)
            self.OtraMoneda = obj_
            obj_.original_tagname_ = 'OtraMoneda'
# end class EncabezadoType


class IdDocType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TipoDTE=None, Folio=None, FchEmis=None, IndNoRebaja=None, TipoDespacho=None, IndTraslado=None, TpoImpresion=None, IndServicio=None, MntBruto=None, TpoTranCompra=None, TpoTranVenta=None, FmaPago=None, FmaPagExp=None, FchCancel=None, MntCancel=None, SaldoInsol=None, MntPagos=None, PeriodoDesde=None, PeriodoHasta=None, MedioPago=None, TpoCtaPago=None, NumCtaPago=None, BcoPago=None, TermPagoCdg=None, TermPagoGlosa=None, TermPagoDias=None, FchVenc=None):
        self.original_tagname_ = None
        self.TipoDTE = TipoDTE
        self.validate_DocCedibleType(self.TipoDTE)
        self.Folio = Folio
        self.validate_DocCedibleFolioType(self.Folio)
        if isinstance(FchEmis, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchEmis, '%Y-%m-%d').date()
        else:
            initvalue_ = FchEmis
        self.FchEmis = initvalue_
        self.IndNoRebaja = IndNoRebaja
        self.validate_IndNoRebajaType(self.IndNoRebaja)
        self.TipoDespacho = TipoDespacho
        self.validate_TipoDespachoType(self.TipoDespacho)
        self.IndTraslado = IndTraslado
        self.validate_IndTrasladoType(self.IndTraslado)
        self.TpoImpresion = TpoImpresion
        self.validate_TpoImpresionType(self.TpoImpresion)
        self.IndServicio = IndServicio
        self.validate_IndServicioType(self.IndServicio)
        self.MntBruto = MntBruto
        self.validate_MntBrutoType(self.MntBruto)
        self.TpoTranCompra = TpoTranCompra
        self.validate_TipoTransCOMPRA(self.TpoTranCompra)
        self.TpoTranVenta = TpoTranVenta
        self.validate_TipoTransVENTA(self.TpoTranVenta)
        self.FmaPago = FmaPago
        self.validate_FmaPagoType(self.FmaPago)
        self.FmaPagExp = FmaPagExp
        self.validate_FmaPagExpType(self.FmaPagExp)
        if isinstance(FchCancel, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchCancel, '%Y-%m-%d').date()
        else:
            initvalue_ = FchCancel
        self.FchCancel = initvalue_
        self.MntCancel = MntCancel
        self.validate_MontoType(self.MntCancel)
        self.SaldoInsol = SaldoInsol
        self.validate_MontoType(self.SaldoInsol)
        if MntPagos is None:
            self.MntPagos = []
        else:
            self.MntPagos = MntPagos
        if isinstance(PeriodoDesde, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PeriodoDesde, '%Y-%m-%d').date()
        else:
            initvalue_ = PeriodoDesde
        self.PeriodoDesde = initvalue_
        if isinstance(PeriodoHasta, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PeriodoHasta, '%Y-%m-%d').date()
        else:
            initvalue_ = PeriodoHasta
        self.PeriodoHasta = initvalue_
        self.MedioPago = MedioPago
        self.validate_MedioPagoType(self.MedioPago)
        self.TpoCtaPago = TpoCtaPago
        self.validate_TpoCtaPagoType(self.TpoCtaPago)
        self.NumCtaPago = NumCtaPago
        self.validate_NumCtaPagoType(self.NumCtaPago)
        self.BcoPago = BcoPago
        self.validate_BcoPagoType(self.BcoPago)
        self.TermPagoCdg = TermPagoCdg
        self.validate_TermPagoCdgType(self.TermPagoCdg)
        self.TermPagoGlosa = TermPagoGlosa
        self.validate_TermPagoGlosaType(self.TermPagoGlosa)
        self.TermPagoDias = TermPagoDias
        self.validate_TermPagoDiasType(self.TermPagoDias)
        if isinstance(FchVenc, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchVenc, '%Y-%m-%d').date()
        else:
            initvalue_ = FchVenc
        self.FchVenc = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdDocType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdDocType.subclass:
            return IdDocType.subclass(*args_, **kwargs_)
        else:
            return IdDocType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoDTE(self): return self.TipoDTE
    def set_TipoDTE(self, TipoDTE): self.TipoDTE = TipoDTE
    def get_Folio(self): return self.Folio
    def set_Folio(self, Folio): self.Folio = Folio
    def get_FchEmis(self): return self.FchEmis
    def set_FchEmis(self, FchEmis): self.FchEmis = FchEmis
    def get_IndNoRebaja(self): return self.IndNoRebaja
    def set_IndNoRebaja(self, IndNoRebaja): self.IndNoRebaja = IndNoRebaja
    def get_TipoDespacho(self): return self.TipoDespacho
    def set_TipoDespacho(self, TipoDespacho): self.TipoDespacho = TipoDespacho
    def get_IndTraslado(self): return self.IndTraslado
    def set_IndTraslado(self, IndTraslado): self.IndTraslado = IndTraslado
    def get_TpoImpresion(self): return self.TpoImpresion
    def set_TpoImpresion(self, TpoImpresion): self.TpoImpresion = TpoImpresion
    def get_IndServicio(self): return self.IndServicio
    def set_IndServicio(self, IndServicio): self.IndServicio = IndServicio
    def get_MntBruto(self): return self.MntBruto
    def set_MntBruto(self, MntBruto): self.MntBruto = MntBruto
    def get_TpoTranCompra(self): return self.TpoTranCompra
    def set_TpoTranCompra(self, TpoTranCompra): self.TpoTranCompra = TpoTranCompra
    def get_TpoTranVenta(self): return self.TpoTranVenta
    def set_TpoTranVenta(self, TpoTranVenta): self.TpoTranVenta = TpoTranVenta
    def get_FmaPago(self): return self.FmaPago
    def set_FmaPago(self, FmaPago): self.FmaPago = FmaPago
    def get_FmaPagExp(self): return self.FmaPagExp
    def set_FmaPagExp(self, FmaPagExp): self.FmaPagExp = FmaPagExp
    def get_FchCancel(self): return self.FchCancel
    def set_FchCancel(self, FchCancel): self.FchCancel = FchCancel
    def get_MntCancel(self): return self.MntCancel
    def set_MntCancel(self, MntCancel): self.MntCancel = MntCancel
    def get_SaldoInsol(self): return self.SaldoInsol
    def set_SaldoInsol(self, SaldoInsol): self.SaldoInsol = SaldoInsol
    def get_MntPagos(self): return self.MntPagos
    def set_MntPagos(self, MntPagos): self.MntPagos = MntPagos
    def add_MntPagos(self, value): self.MntPagos.append(value)
    def insert_MntPagos_at(self, index, value): self.MntPagos.insert(index, value)
    def replace_MntPagos_at(self, index, value): self.MntPagos[index] = value
    def get_PeriodoDesde(self): return self.PeriodoDesde
    def set_PeriodoDesde(self, PeriodoDesde): self.PeriodoDesde = PeriodoDesde
    def get_PeriodoHasta(self): return self.PeriodoHasta
    def set_PeriodoHasta(self, PeriodoHasta): self.PeriodoHasta = PeriodoHasta
    def get_MedioPago(self): return self.MedioPago
    def set_MedioPago(self, MedioPago): self.MedioPago = MedioPago
    def get_TpoCtaPago(self): return self.TpoCtaPago
    def set_TpoCtaPago(self, TpoCtaPago): self.TpoCtaPago = TpoCtaPago
    def get_NumCtaPago(self): return self.NumCtaPago
    def set_NumCtaPago(self, NumCtaPago): self.NumCtaPago = NumCtaPago
    def get_BcoPago(self): return self.BcoPago
    def set_BcoPago(self, BcoPago): self.BcoPago = BcoPago
    def get_TermPagoCdg(self): return self.TermPagoCdg
    def set_TermPagoCdg(self, TermPagoCdg): self.TermPagoCdg = TermPagoCdg
    def get_TermPagoGlosa(self): return self.TermPagoGlosa
    def set_TermPagoGlosa(self, TermPagoGlosa): self.TermPagoGlosa = TermPagoGlosa
    def get_TermPagoDias(self): return self.TermPagoDias
    def set_TermPagoDias(self, TermPagoDias): self.TermPagoDias = TermPagoDias
    def get_FchVenc(self): return self.FchVenc
    def set_FchVenc(self, FchVenc): self.FchVenc = FchVenc
    def validate_DocCedibleType(self, value):
        # Validate type DocCedibleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['801', '803', '805', '806', '901', '902']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocCedibleType' % {"value" : value.encode("utf-8")} )
    def validate_DocCedibleFolioType(self, value):
        # Validate type DocCedibleFolioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DocCedibleFolioType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DocCedibleFolioType' % {"value" : value.encode("utf-8")} )
    def validate_FechaType(self, value):
        # Validate type FechaType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_date('2000-01-01'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaType' % {"value" : value} )
            if value > self.gds_parse_date('2050-12-31'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaType' % {"value" : value} )
    def validate_IndNoRebajaType(self, value):
        # Validate type IndNoRebajaType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndNoRebajaType' % {"value" : value.encode("utf-8")} )
    def validate_TipoDespachoType(self, value):
        # Validate type TipoDespachoType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TipoDespachoType' % {"value" : value.encode("utf-8")} )
    def validate_IndTrasladoType(self, value):
        # Validate type IndTrasladoType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndTrasladoType' % {"value" : value.encode("utf-8")} )
    def validate_TpoImpresionType(self, value):
        # Validate type TpoImpresionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['N', 'T']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TpoImpresionType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on TpoImpresionType' % {"value" : value.encode("utf-8")} )
    def validate_IndServicioType(self, value):
        # Validate type IndServicioType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndServicioType' % {"value" : value.encode("utf-8")} )
    def validate_MntBrutoType(self, value):
        # Validate type MntBrutoType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MntBrutoType' % {"value" : value.encode("utf-8")} )
    def validate_TipoTransCOMPRA(self, value):
        # Validate type TipoTransCOMPRA, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TipoTransCOMPRA' % {"value" : value.encode("utf-8")} )
    def validate_TipoTransVENTA(self, value):
        # Validate type TipoTransVENTA, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TipoTransVENTA' % {"value" : value.encode("utf-8")} )
    def validate_FmaPagoType(self, value):
        # Validate type FmaPagoType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FmaPagoType' % {"value" : value.encode("utf-8")} )
    def validate_FmaPagExpType(self, value):
        # Validate type FmaPagExpType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FmaPagExpType' % {"value" : value} )
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def validate_MedioPagoType(self, value):
        # Validate type MedioPagoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CH', 'LT', 'EF', 'PE', 'TC', 'CF', 'OT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MedioPagoType' % {"value" : value.encode("utf-8")} )
    def validate_TpoCtaPagoType(self, value):
        # Validate type TpoCtaPagoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AHORRO', 'CORRIENTE', 'VISTA']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TpoCtaPagoType' % {"value" : value.encode("utf-8")} )
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TpoCtaPagoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 5:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TpoCtaPagoType' % {"value" : value.encode("utf-8")} )
    def validate_NumCtaPagoType(self, value):
        # Validate type NumCtaPagoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on NumCtaPagoType' % {"value" : value.encode("utf-8")} )
    def validate_BcoPagoType(self, value):
        # Validate type BcoPagoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on BcoPagoType' % {"value" : value.encode("utf-8")} )
    def validate_TermPagoCdgType(self, value):
        # Validate type TermPagoCdgType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TermPagoCdgType' % {"value" : value.encode("utf-8")} )
    def validate_TermPagoGlosaType(self, value):
        # Validate type TermPagoGlosaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TermPagoGlosaType' % {"value" : value.encode("utf-8")} )
    def validate_TermPagoDiasType(self, value):
        # Validate type TermPagoDiasType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TermPagoDiasType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoDTE is not None or
            self.Folio is not None or
            self.FchEmis is not None or
            self.IndNoRebaja is not None or
            self.TipoDespacho is not None or
            self.IndTraslado is not None or
            self.TpoImpresion is not None or
            self.IndServicio is not None or
            self.MntBruto is not None or
            self.TpoTranCompra is not None or
            self.TpoTranVenta is not None or
            self.FmaPago is not None or
            self.FmaPagExp is not None or
            self.FchCancel is not None or
            self.MntCancel is not None or
            self.SaldoInsol is not None or
            self.MntPagos or
            self.PeriodoDesde is not None or
            self.PeriodoHasta is not None or
            self.MedioPago is not None or
            self.TpoCtaPago is not None or
            self.NumCtaPago is not None or
            self.BcoPago is not None or
            self.TermPagoCdg is not None or
            self.TermPagoGlosa is not None or
            self.TermPagoDias is not None or
            self.FchVenc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='IdDocType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdDocType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdDocType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='IdDocType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='IdDocType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='IdDocType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoDTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoDTE>%s</SiiDte:TipoDTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoDTE), input_name='TipoDTE')), eol_))
        if self.Folio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Folio>%s</SiiDte:Folio>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Folio), input_name='Folio')), eol_))
        if self.FchEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchEmis>%s</SiiDte:FchEmis>%s' % (self.gds_format_date(self.FchEmis, input_name='FchEmis'), eol_))
        if self.IndNoRebaja is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndNoRebaja>%s</SiiDte:IndNoRebaja>%s' % (self.gds_format_integer(self.IndNoRebaja, input_name='IndNoRebaja'), eol_))
        if self.TipoDespacho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoDespacho>%s</SiiDte:TipoDespacho>%s' % (self.gds_format_integer(self.TipoDespacho, input_name='TipoDespacho'), eol_))
        if self.IndTraslado is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndTraslado>%s</SiiDte:IndTraslado>%s' % (self.gds_format_integer(self.IndTraslado, input_name='IndTraslado'), eol_))
        if self.TpoImpresion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoImpresion>%s</SiiDte:TpoImpresion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoImpresion), input_name='TpoImpresion')), eol_))
        if self.IndServicio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndServicio>%s</SiiDte:IndServicio>%s' % (self.gds_format_integer(self.IndServicio, input_name='IndServicio'), eol_))
        if self.MntBruto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntBruto>%s</SiiDte:MntBruto>%s' % (self.gds_format_integer(self.MntBruto, input_name='MntBruto'), eol_))
        if self.TpoTranCompra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoTranCompra>%s</SiiDte:TpoTranCompra>%s' % (self.gds_format_integer(self.TpoTranCompra, input_name='TpoTranCompra'), eol_))
        if self.TpoTranVenta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoTranVenta>%s</SiiDte:TpoTranVenta>%s' % (self.gds_format_integer(self.TpoTranVenta, input_name='TpoTranVenta'), eol_))
        if self.FmaPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FmaPago>%s</SiiDte:FmaPago>%s' % (self.gds_format_integer(self.FmaPago, input_name='FmaPago'), eol_))
        if self.FmaPagExp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FmaPagExp>%s</SiiDte:FmaPagExp>%s' % (self.gds_format_integer(self.FmaPagExp, input_name='FmaPagExp'), eol_))
        if self.FchCancel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchCancel>%s</SiiDte:FchCancel>%s' % (self.gds_format_date(self.FchCancel, input_name='FchCancel'), eol_))
        if self.MntCancel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntCancel>%s</SiiDte:MntCancel>%s' % (self.gds_format_integer(self.MntCancel, input_name='MntCancel'), eol_))
        if self.SaldoInsol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SaldoInsol>%s</SiiDte:SaldoInsol>%s' % (self.gds_format_integer(self.SaldoInsol, input_name='SaldoInsol'), eol_))
        for MntPagos_ in self.MntPagos:
            MntPagos_.export(outfile, level, namespaceprefix_, name_='MntPagos', pretty_print=pretty_print)
        if self.PeriodoDesde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PeriodoDesde>%s</SiiDte:PeriodoDesde>%s' % (self.gds_format_date(self.PeriodoDesde, input_name='PeriodoDesde'), eol_))
        if self.PeriodoHasta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PeriodoHasta>%s</SiiDte:PeriodoHasta>%s' % (self.gds_format_date(self.PeriodoHasta, input_name='PeriodoHasta'), eol_))
        if self.MedioPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MedioPago>%s</SiiDte:MedioPago>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MedioPago), input_name='MedioPago')), eol_))
        if self.TpoCtaPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoCtaPago>%s</SiiDte:TpoCtaPago>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoCtaPago), input_name='TpoCtaPago')), eol_))
        if self.NumCtaPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NumCtaPago>%s</SiiDte:NumCtaPago>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumCtaPago), input_name='NumCtaPago')), eol_))
        if self.BcoPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:BcoPago>%s</SiiDte:BcoPago>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BcoPago), input_name='BcoPago')), eol_))
        if self.TermPagoCdg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TermPagoCdg>%s</SiiDte:TermPagoCdg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TermPagoCdg), input_name='TermPagoCdg')), eol_))
        if self.TermPagoGlosa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TermPagoGlosa>%s</SiiDte:TermPagoGlosa>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TermPagoGlosa), input_name='TermPagoGlosa')), eol_))
        if self.TermPagoDias is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TermPagoDias>%s</SiiDte:TermPagoDias>%s' % (self.gds_format_integer(self.TermPagoDias, input_name='TermPagoDias'), eol_))
        if self.FchVenc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchVenc>%s</SiiDte:FchVenc>%s' % (self.gds_format_date(self.FchVenc, input_name='FchVenc'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoDTE':
            TipoDTE_ = child_.text
            TipoDTE_ = self.gds_validate_string(TipoDTE_, node, 'TipoDTE')
            self.TipoDTE = TipoDTE_
            # validate type DocCedibleType
            self.validate_DocCedibleType(self.TipoDTE)
        elif nodeName_ == 'Folio':
            Folio_ = child_.text
            Folio_ = self.gds_validate_string(Folio_, node, 'Folio')
            self.Folio = Folio_
            # validate type DocCedibleFolioType
            self.validate_DocCedibleFolioType(self.Folio)
        elif nodeName_ == 'FchEmis':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchEmis = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchEmis)
        elif nodeName_ == 'IndNoRebaja' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndNoRebaja')
            self.IndNoRebaja = ival_
            # validate type IndNoRebajaType
            self.validate_IndNoRebajaType(self.IndNoRebaja)
        elif nodeName_ == 'TipoDespacho' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'TipoDespacho')
            self.TipoDespacho = ival_
            # validate type TipoDespachoType
            self.validate_TipoDespachoType(self.TipoDespacho)
        elif nodeName_ == 'IndTraslado' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndTraslado')
            self.IndTraslado = ival_
            # validate type IndTrasladoType
            self.validate_IndTrasladoType(self.IndTraslado)
        elif nodeName_ == 'TpoImpresion':
            TpoImpresion_ = child_.text
            TpoImpresion_ = self.gds_validate_string(TpoImpresion_, node, 'TpoImpresion')
            self.TpoImpresion = TpoImpresion_
            # validate type TpoImpresionType
            self.validate_TpoImpresionType(self.TpoImpresion)
        elif nodeName_ == 'IndServicio' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndServicio')
            self.IndServicio = ival_
            # validate type IndServicioType
            self.validate_IndServicioType(self.IndServicio)
        elif nodeName_ == 'MntBruto' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MntBruto')
            self.MntBruto = ival_
            # validate type MntBrutoType
            self.validate_MntBrutoType(self.MntBruto)
        elif nodeName_ == 'TpoTranCompra' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'TpoTranCompra')
            self.TpoTranCompra = ival_
            # validate type TipoTransCOMPRA
            self.validate_TipoTransCOMPRA(self.TpoTranCompra)
        elif nodeName_ == 'TpoTranVenta' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'TpoTranVenta')
            self.TpoTranVenta = ival_
            # validate type TipoTransVENTA
            self.validate_TipoTransVENTA(self.TpoTranVenta)
        elif nodeName_ == 'FmaPago' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'FmaPago')
            self.FmaPago = ival_
            # validate type FmaPagoType
            self.validate_FmaPagoType(self.FmaPago)
        elif nodeName_ == 'FmaPagExp' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'FmaPagExp')
            self.FmaPagExp = ival_
            # validate type FmaPagExpType
            self.validate_FmaPagExpType(self.FmaPagExp)
        elif nodeName_ == 'FchCancel':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchCancel = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchCancel)
        elif nodeName_ == 'MntCancel' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntCancel')
            self.MntCancel = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntCancel)
        elif nodeName_ == 'SaldoInsol' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SaldoInsol')
            self.SaldoInsol = ival_
            # validate type MontoType
            self.validate_MontoType(self.SaldoInsol)
        elif nodeName_ == 'MntPagos':
            obj_ = MntPagosType.factory()
            obj_.build(child_)
            self.MntPagos.append(obj_)
            obj_.original_tagname_ = 'MntPagos'
        elif nodeName_ == 'PeriodoDesde':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PeriodoDesde = dval_
            # validate type FechaType
            self.validate_FechaType(self.PeriodoDesde)
        elif nodeName_ == 'PeriodoHasta':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PeriodoHasta = dval_
            # validate type FechaType
            self.validate_FechaType(self.PeriodoHasta)
        elif nodeName_ == 'MedioPago':
            MedioPago_ = child_.text
            MedioPago_ = self.gds_validate_string(MedioPago_, node, 'MedioPago')
            self.MedioPago = MedioPago_
            # validate type MedioPagoType
            self.validate_MedioPagoType(self.MedioPago)
        elif nodeName_ == 'TpoCtaPago':
            TpoCtaPago_ = child_.text
            TpoCtaPago_ = self.gds_validate_string(TpoCtaPago_, node, 'TpoCtaPago')
            self.TpoCtaPago = TpoCtaPago_
            # validate type TpoCtaPagoType
            self.validate_TpoCtaPagoType(self.TpoCtaPago)
        elif nodeName_ == 'NumCtaPago':
            NumCtaPago_ = child_.text
            NumCtaPago_ = self.gds_validate_string(NumCtaPago_, node, 'NumCtaPago')
            self.NumCtaPago = NumCtaPago_
            # validate type NumCtaPagoType
            self.validate_NumCtaPagoType(self.NumCtaPago)
        elif nodeName_ == 'BcoPago':
            BcoPago_ = child_.text
            BcoPago_ = self.gds_validate_string(BcoPago_, node, 'BcoPago')
            self.BcoPago = BcoPago_
            # validate type BcoPagoType
            self.validate_BcoPagoType(self.BcoPago)
        elif nodeName_ == 'TermPagoCdg':
            TermPagoCdg_ = child_.text
            TermPagoCdg_ = self.gds_validate_string(TermPagoCdg_, node, 'TermPagoCdg')
            self.TermPagoCdg = TermPagoCdg_
            # validate type TermPagoCdgType
            self.validate_TermPagoCdgType(self.TermPagoCdg)
        elif nodeName_ == 'TermPagoGlosa':
            TermPagoGlosa_ = child_.text
            TermPagoGlosa_ = self.gds_validate_string(TermPagoGlosa_, node, 'TermPagoGlosa')
            self.TermPagoGlosa = TermPagoGlosa_
            # validate type TermPagoGlosaType
            self.validate_TermPagoGlosaType(self.TermPagoGlosa)
        elif nodeName_ == 'TermPagoDias' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'TermPagoDias')
            self.TermPagoDias = ival_
            # validate type TermPagoDiasType
            self.validate_TermPagoDiasType(self.TermPagoDias)
        elif nodeName_ == 'FchVenc':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchVenc = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchVenc)
# end class IdDocType


class MntPagosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FchPago=None, MntPago=None, GlosaPagos=None):
        self.original_tagname_ = None
        if isinstance(FchPago, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchPago, '%Y-%m-%d').date()
        else:
            initvalue_ = FchPago
        self.FchPago = initvalue_
        self.MntPago = MntPago
        self.validate_MontoType(self.MntPago)
        self.GlosaPagos = GlosaPagos
        self.validate_GlosaPagosType(self.GlosaPagos)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MntPagosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MntPagosType.subclass:
            return MntPagosType.subclass(*args_, **kwargs_)
        else:
            return MntPagosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FchPago(self): return self.FchPago
    def set_FchPago(self, FchPago): self.FchPago = FchPago
    def get_MntPago(self): return self.MntPago
    def set_MntPago(self, MntPago): self.MntPago = MntPago
    def get_GlosaPagos(self): return self.GlosaPagos
    def set_GlosaPagos(self, GlosaPagos): self.GlosaPagos = GlosaPagos
    def validate_FechaType(self, value):
        # Validate type FechaType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_date('2000-01-01'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaType' % {"value" : value} )
            if value > self.gds_parse_date('2050-12-31'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaType' % {"value" : value} )
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def validate_GlosaPagosType(self, value):
        # Validate type GlosaPagosType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlosaPagosType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FchPago is not None or
            self.MntPago is not None or
            self.GlosaPagos is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='MntPagosType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MntPagosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MntPagosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='MntPagosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='MntPagosType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='MntPagosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FchPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchPago>%s</SiiDte:FchPago>%s' % (self.gds_format_date(self.FchPago, input_name='FchPago'), eol_))
        if self.MntPago is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntPago>%s</SiiDte:MntPago>%s' % (self.gds_format_integer(self.MntPago, input_name='MntPago'), eol_))
        if self.GlosaPagos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GlosaPagos>%s</SiiDte:GlosaPagos>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlosaPagos), input_name='GlosaPagos')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FchPago':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchPago = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchPago)
        elif nodeName_ == 'MntPago' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntPago')
            self.MntPago = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntPago)
        elif nodeName_ == 'GlosaPagos':
            GlosaPagos_ = child_.text
            GlosaPagos_ = self.gds_validate_string(GlosaPagos_, node, 'GlosaPagos')
            self.GlosaPagos = GlosaPagos_
            # validate type GlosaPagosType
            self.validate_GlosaPagosType(self.GlosaPagos)
# end class MntPagosType


class EmisorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RUTEmisor=None, RznSoc=None, GiroEmis=None, Telefono=None, CorreoEmisor=None, Acteco=None, GuiaExport=None, Sucursal=None, CdgSIISucur=None, DirOrigen=None, CmnaOrigen=None, CiudadOrigen=None, CdgVendedor=None, IdAdicEmisor=None):
        self.original_tagname_ = None
        self.RUTEmisor = RUTEmisor
        self.validate_RUTType(self.RUTEmisor)
        self.RznSoc = RznSoc
        self.validate_RznSocType(self.RznSoc)
        self.GiroEmis = GiroEmis
        self.validate_GiroEmisType(self.GiroEmis)
        if Telefono is None:
            self.Telefono = []
        else:
            self.Telefono = Telefono
        self.CorreoEmisor = CorreoEmisor
        self.validate_MailType(self.CorreoEmisor)
        if Acteco is None:
            self.Acteco = []
        else:
            self.Acteco = Acteco
        self.GuiaExport = GuiaExport
        self.Sucursal = Sucursal
        self.validate_SucursalType(self.Sucursal)
        self.CdgSIISucur = CdgSIISucur
        self.validate_CdgSIISucurType(self.CdgSIISucur)
        self.DirOrigen = DirOrigen
        self.validate_DirOrigenType(self.DirOrigen)
        self.CmnaOrigen = CmnaOrigen
        self.validate_ComunaType(self.CmnaOrigen)
        self.CiudadOrigen = CiudadOrigen
        self.validate_CiudadType(self.CiudadOrigen)
        self.CdgVendedor = CdgVendedor
        self.validate_CdgVendedorType(self.CdgVendedor)
        self.IdAdicEmisor = IdAdicEmisor
        self.validate_IdAdicEmisorType(self.IdAdicEmisor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmisorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmisorType.subclass:
            return EmisorType.subclass(*args_, **kwargs_)
        else:
            return EmisorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RUTEmisor(self): return self.RUTEmisor
    def set_RUTEmisor(self, RUTEmisor): self.RUTEmisor = RUTEmisor
    def get_RznSoc(self): return self.RznSoc
    def set_RznSoc(self, RznSoc): self.RznSoc = RznSoc
    def get_GiroEmis(self): return self.GiroEmis
    def set_GiroEmis(self, GiroEmis): self.GiroEmis = GiroEmis
    def get_Telefono(self): return self.Telefono
    def set_Telefono(self, Telefono): self.Telefono = Telefono
    def add_Telefono(self, value): self.Telefono.append(value)
    def insert_Telefono_at(self, index, value): self.Telefono.insert(index, value)
    def replace_Telefono_at(self, index, value): self.Telefono[index] = value
    def get_CorreoEmisor(self): return self.CorreoEmisor
    def set_CorreoEmisor(self, CorreoEmisor): self.CorreoEmisor = CorreoEmisor
    def get_Acteco(self): return self.Acteco
    def set_Acteco(self, Acteco): self.Acteco = Acteco
    def add_Acteco(self, value): self.Acteco.append(value)
    def insert_Acteco_at(self, index, value): self.Acteco.insert(index, value)
    def replace_Acteco_at(self, index, value): self.Acteco[index] = value
    def get_GuiaExport(self): return self.GuiaExport
    def set_GuiaExport(self, GuiaExport): self.GuiaExport = GuiaExport
    def get_Sucursal(self): return self.Sucursal
    def set_Sucursal(self, Sucursal): self.Sucursal = Sucursal
    def get_CdgSIISucur(self): return self.CdgSIISucur
    def set_CdgSIISucur(self, CdgSIISucur): self.CdgSIISucur = CdgSIISucur
    def get_DirOrigen(self): return self.DirOrigen
    def set_DirOrigen(self, DirOrigen): self.DirOrigen = DirOrigen
    def get_CmnaOrigen(self): return self.CmnaOrigen
    def set_CmnaOrigen(self, CmnaOrigen): self.CmnaOrigen = CmnaOrigen
    def get_CiudadOrigen(self): return self.CiudadOrigen
    def set_CiudadOrigen(self, CiudadOrigen): self.CiudadOrigen = CiudadOrigen
    def get_CdgVendedor(self): return self.CdgVendedor
    def set_CdgVendedor(self, CdgVendedor): self.CdgVendedor = CdgVendedor
    def get_IdAdicEmisor(self): return self.IdAdicEmisor
    def set_IdAdicEmisor(self, IdAdicEmisor): self.IdAdicEmisor = IdAdicEmisor
    def validate_RUTType(self, value):
        # Validate type RUTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_RUTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RUTType_patterns_, ))
    validate_RUTType_patterns_ = [[u'^[0-9]+-([0-9]|K)$']]
    def validate_RznSocType(self, value):
        # Validate type RznSocType, a restriction on SiiDte:RznSocLargaType.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RznSocType' % {"value" : value} )
    def validate_GiroEmisType(self, value):
        # Validate type GiroEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GiroEmisType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on GiroEmisType' % {"value" : value.encode("utf-8")} )
    def validate_TelefonoType(self, value):
        # Validate type TelefonoType, a restriction on SiiDte:FonoType.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TelefonoType' % {"value" : value} )
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TelefonoType' % {"value" : value} )
    def validate_MailType(self, value):
        # Validate type MailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on MailType' % {"value" : value.encode("utf-8")} )
    def validate_ActecoType(self, value):
        # Validate type ActecoType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ActecoType' % {"value" : value} )
    def validate_SucursalType(self, value):
        # Validate type SucursalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SucursalType' % {"value" : value.encode("utf-8")} )
    def validate_CdgSIISucurType(self, value):
        # Validate type CdgSIISucurType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on CdgSIISucurType' % {"value" : value} )
    def validate_DirOrigenType(self, value):
        # Validate type DirOrigenType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DirOrigenType' % {"value" : value.encode("utf-8")} )
    def validate_ComunaType(self, value):
        # Validate type ComunaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ComunaType' % {"value" : value.encode("utf-8")} )
    def validate_CiudadType(self, value):
        # Validate type CiudadType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CiudadType' % {"value" : value.encode("utf-8")} )
    def validate_CdgVendedorType(self, value):
        # Validate type CdgVendedorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CdgVendedorType' % {"value" : value.encode("utf-8")} )
    def validate_IdAdicEmisorType(self, value):
        # Validate type IdAdicEmisorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IdAdicEmisorType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on IdAdicEmisorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RUTEmisor is not None or
            self.RznSoc is not None or
            self.GiroEmis is not None or
            self.Telefono or
            self.CorreoEmisor is not None or
            self.Acteco or
            self.GuiaExport is not None or
            self.Sucursal is not None or
            self.CdgSIISucur is not None or
            self.DirOrigen is not None or
            self.CmnaOrigen is not None or
            self.CiudadOrigen is not None or
            self.CdgVendedor is not None or
            self.IdAdicEmisor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='EmisorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EmisorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EmisorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='EmisorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='EmisorType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='EmisorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RUTEmisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RUTEmisor>%s</SiiDte:RUTEmisor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RUTEmisor), input_name='RUTEmisor')), eol_))
        if self.RznSoc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RznSoc>%s</SiiDte:RznSoc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RznSoc), input_name='RznSoc')), eol_))
        if self.GiroEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GiroEmis>%s</SiiDte:GiroEmis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GiroEmis), input_name='GiroEmis')), eol_))
        for Telefono_ in self.Telefono:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Telefono>%s</SiiDte:Telefono>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Telefono_), input_name='Telefono')), eol_))
        if self.CorreoEmisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CorreoEmisor>%s</SiiDte:CorreoEmisor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CorreoEmisor), input_name='CorreoEmisor')), eol_))
        for Acteco_ in self.Acteco:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Acteco>%s</SiiDte:Acteco>%s' % (self.gds_format_integer(Acteco_, input_name='Acteco'), eol_))
        if self.GuiaExport is not None:
            self.GuiaExport.export(outfile, level, namespaceprefix_, name_='GuiaExport', pretty_print=pretty_print)
        if self.Sucursal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Sucursal>%s</SiiDte:Sucursal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Sucursal), input_name='Sucursal')), eol_))
        if self.CdgSIISucur is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CdgSIISucur>%s</SiiDte:CdgSIISucur>%s' % (self.gds_format_integer(self.CdgSIISucur, input_name='CdgSIISucur'), eol_))
        if self.DirOrigen is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DirOrigen>%s</SiiDte:DirOrigen>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DirOrigen), input_name='DirOrigen')), eol_))
        if self.CmnaOrigen is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CmnaOrigen>%s</SiiDte:CmnaOrigen>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CmnaOrigen), input_name='CmnaOrigen')), eol_))
        if self.CiudadOrigen is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CiudadOrigen>%s</SiiDte:CiudadOrigen>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CiudadOrigen), input_name='CiudadOrigen')), eol_))
        if self.CdgVendedor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CdgVendedor>%s</SiiDte:CdgVendedor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CdgVendedor), input_name='CdgVendedor')), eol_))
        if self.IdAdicEmisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IdAdicEmisor>%s</SiiDte:IdAdicEmisor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IdAdicEmisor), input_name='IdAdicEmisor')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUTEmisor':
            RUTEmisor_ = child_.text
            RUTEmisor_ = self.gds_validate_string(RUTEmisor_, node, 'RUTEmisor')
            self.RUTEmisor = RUTEmisor_
            # validate type RUTType
            self.validate_RUTType(self.RUTEmisor)
        elif nodeName_ == 'RznSoc':
            RznSoc_ = child_.text
            RznSoc_ = self.gds_validate_string(RznSoc_, node, 'RznSoc')
            self.RznSoc = RznSoc_
            # validate type RznSocType
            self.validate_RznSocType(self.RznSoc)
        elif nodeName_ == 'GiroEmis':
            GiroEmis_ = child_.text
            GiroEmis_ = self.gds_validate_string(GiroEmis_, node, 'GiroEmis')
            self.GiroEmis = GiroEmis_
            # validate type GiroEmisType
            self.validate_GiroEmisType(self.GiroEmis)
        elif nodeName_ == 'Telefono':
            Telefono_ = child_.text
            Telefono_ = self.gds_validate_string(Telefono_, node, 'Telefono')
            self.Telefono.append(Telefono_)
            # validate type TelefonoType
            self.validate_TelefonoType(self.Telefono[-1])
        elif nodeName_ == 'CorreoEmisor':
            CorreoEmisor_ = child_.text
            CorreoEmisor_ = self.gds_validate_string(CorreoEmisor_, node, 'CorreoEmisor')
            self.CorreoEmisor = CorreoEmisor_
            # validate type MailType
            self.validate_MailType(self.CorreoEmisor)
        elif nodeName_ == 'Acteco' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Acteco')
            self.Acteco.append(ival_)
            # validate type ActecoType
            self.validate_ActecoType(self.Acteco[-1])
        elif nodeName_ == 'GuiaExport':
            obj_ = GuiaExportType.factory()
            obj_.build(child_)
            self.GuiaExport = obj_
            obj_.original_tagname_ = 'GuiaExport'
        elif nodeName_ == 'Sucursal':
            Sucursal_ = child_.text
            Sucursal_ = self.gds_validate_string(Sucursal_, node, 'Sucursal')
            self.Sucursal = Sucursal_
            # validate type SucursalType
            self.validate_SucursalType(self.Sucursal)
        elif nodeName_ == 'CdgSIISucur' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CdgSIISucur')
            self.CdgSIISucur = ival_
            # validate type CdgSIISucurType
            self.validate_CdgSIISucurType(self.CdgSIISucur)
        elif nodeName_ == 'DirOrigen':
            DirOrigen_ = child_.text
            DirOrigen_ = self.gds_validate_string(DirOrigen_, node, 'DirOrigen')
            self.DirOrigen = DirOrigen_
            # validate type DirOrigenType
            self.validate_DirOrigenType(self.DirOrigen)
        elif nodeName_ == 'CmnaOrigen':
            CmnaOrigen_ = child_.text
            CmnaOrigen_ = self.gds_validate_string(CmnaOrigen_, node, 'CmnaOrigen')
            self.CmnaOrigen = CmnaOrigen_
            # validate type ComunaType
            self.validate_ComunaType(self.CmnaOrigen)
        elif nodeName_ == 'CiudadOrigen':
            CiudadOrigen_ = child_.text
            CiudadOrigen_ = self.gds_validate_string(CiudadOrigen_, node, 'CiudadOrigen')
            self.CiudadOrigen = CiudadOrigen_
            # validate type CiudadType
            self.validate_CiudadType(self.CiudadOrigen)
        elif nodeName_ == 'CdgVendedor':
            CdgVendedor_ = child_.text
            CdgVendedor_ = self.gds_validate_string(CdgVendedor_, node, 'CdgVendedor')
            self.CdgVendedor = CdgVendedor_
            # validate type CdgVendedorType
            self.validate_CdgVendedorType(self.CdgVendedor)
        elif nodeName_ == 'IdAdicEmisor':
            IdAdicEmisor_ = child_.text
            IdAdicEmisor_ = self.gds_validate_string(IdAdicEmisor_, node, 'IdAdicEmisor')
            self.IdAdicEmisor = IdAdicEmisor_
            # validate type IdAdicEmisorType
            self.validate_IdAdicEmisorType(self.IdAdicEmisor)
# end class EmisorType


class GuiaExportType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CdgTraslado=None, FolioAut=None, FchAut=None):
        self.original_tagname_ = None
        self.CdgTraslado = CdgTraslado
        self.validate_CdgTrasladoType(self.CdgTraslado)
        self.FolioAut = FolioAut
        self.validate_NroResolType(self.FolioAut)
        if isinstance(FchAut, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchAut, '%Y-%m-%d').date()
        else:
            initvalue_ = FchAut
        self.FchAut = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GuiaExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GuiaExportType.subclass:
            return GuiaExportType.subclass(*args_, **kwargs_)
        else:
            return GuiaExportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CdgTraslado(self): return self.CdgTraslado
    def set_CdgTraslado(self, CdgTraslado): self.CdgTraslado = CdgTraslado
    def get_FolioAut(self): return self.FolioAut
    def set_FolioAut(self, FolioAut): self.FolioAut = FolioAut
    def get_FchAut(self): return self.FchAut
    def set_FchAut(self, FchAut): self.FchAut = FchAut
    def validate_CdgTrasladoType(self, value):
        # Validate type CdgTrasladoType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CdgTrasladoType' % {"value" : value.encode("utf-8")} )
            if len(str(value)) >= 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on CdgTrasladoType' % {"value" : value} )
    def validate_NroResolType(self, value):
        # Validate type NroResolType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NroResolType' % {"value" : value} )
    def validate_FechaType(self, value):
        # Validate type FechaType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_date('2000-01-01'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaType' % {"value" : value} )
            if value > self.gds_parse_date('2050-12-31'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.CdgTraslado is not None or
            self.FolioAut is not None or
            self.FchAut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='GuiaExportType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GuiaExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GuiaExportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='GuiaExportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='GuiaExportType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='GuiaExportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CdgTraslado is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CdgTraslado>%s</SiiDte:CdgTraslado>%s' % (self.gds_format_integer(self.CdgTraslado, input_name='CdgTraslado'), eol_))
        if self.FolioAut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FolioAut>%s</SiiDte:FolioAut>%s' % (self.gds_format_integer(self.FolioAut, input_name='FolioAut'), eol_))
        if self.FchAut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchAut>%s</SiiDte:FchAut>%s' % (self.gds_format_date(self.FchAut, input_name='FchAut'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CdgTraslado' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CdgTraslado')
            self.CdgTraslado = ival_
            # validate type CdgTrasladoType
            self.validate_CdgTrasladoType(self.CdgTraslado)
        elif nodeName_ == 'FolioAut' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'FolioAut')
            self.FolioAut = ival_
            # validate type NroResolType
            self.validate_NroResolType(self.FolioAut)
        elif nodeName_ == 'FchAut':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchAut = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchAut)
# end class GuiaExportType


class ReceptorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RUTRecep=None, CdgIntRecep=None, RznSocRecep=None, Extranjero=None, GiroRecep=None, Contacto=None, CorreoRecep=None, DirRecep=None, CmnaRecep=None, CiudadRecep=None, DirPostal=None, CmnaPostal=None, CiudadPostal=None):
        self.original_tagname_ = None
        self.RUTRecep = RUTRecep
        self.validate_RUTType(self.RUTRecep)
        self.CdgIntRecep = CdgIntRecep
        self.validate_CdgIntRecepType(self.CdgIntRecep)
        self.RznSocRecep = RznSocRecep
        self.validate_RznSocLargaType(self.RznSocRecep)
        self.Extranjero = Extranjero
        self.GiroRecep = GiroRecep
        self.validate_GiroRecepType(self.GiroRecep)
        self.Contacto = Contacto
        self.validate_ContactoType(self.Contacto)
        self.CorreoRecep = CorreoRecep
        self.validate_MailType(self.CorreoRecep)
        self.DirRecep = DirRecep
        self.validate_DirRecepType(self.DirRecep)
        self.CmnaRecep = CmnaRecep
        self.validate_ComunaType(self.CmnaRecep)
        self.CiudadRecep = CiudadRecep
        self.validate_CiudadType(self.CiudadRecep)
        self.DirPostal = DirPostal
        self.validate_DirPostalType(self.DirPostal)
        self.CmnaPostal = CmnaPostal
        self.validate_ComunaType(self.CmnaPostal)
        self.CiudadPostal = CiudadPostal
        self.validate_CiudadType(self.CiudadPostal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType.subclass:
            return ReceptorType.subclass(*args_, **kwargs_)
        else:
            return ReceptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RUTRecep(self): return self.RUTRecep
    def set_RUTRecep(self, RUTRecep): self.RUTRecep = RUTRecep
    def get_CdgIntRecep(self): return self.CdgIntRecep
    def set_CdgIntRecep(self, CdgIntRecep): self.CdgIntRecep = CdgIntRecep
    def get_RznSocRecep(self): return self.RznSocRecep
    def set_RznSocRecep(self, RznSocRecep): self.RznSocRecep = RznSocRecep
    def get_Extranjero(self): return self.Extranjero
    def set_Extranjero(self, Extranjero): self.Extranjero = Extranjero
    def get_GiroRecep(self): return self.GiroRecep
    def set_GiroRecep(self, GiroRecep): self.GiroRecep = GiroRecep
    def get_Contacto(self): return self.Contacto
    def set_Contacto(self, Contacto): self.Contacto = Contacto
    def get_CorreoRecep(self): return self.CorreoRecep
    def set_CorreoRecep(self, CorreoRecep): self.CorreoRecep = CorreoRecep
    def get_DirRecep(self): return self.DirRecep
    def set_DirRecep(self, DirRecep): self.DirRecep = DirRecep
    def get_CmnaRecep(self): return self.CmnaRecep
    def set_CmnaRecep(self, CmnaRecep): self.CmnaRecep = CmnaRecep
    def get_CiudadRecep(self): return self.CiudadRecep
    def set_CiudadRecep(self, CiudadRecep): self.CiudadRecep = CiudadRecep
    def get_DirPostal(self): return self.DirPostal
    def set_DirPostal(self, DirPostal): self.DirPostal = DirPostal
    def get_CmnaPostal(self): return self.CmnaPostal
    def set_CmnaPostal(self, CmnaPostal): self.CmnaPostal = CmnaPostal
    def get_CiudadPostal(self): return self.CiudadPostal
    def set_CiudadPostal(self, CiudadPostal): self.CiudadPostal = CiudadPostal
    def validate_RUTType(self, value):
        # Validate type RUTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_RUTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RUTType_patterns_, ))
    validate_RUTType_patterns_ = [[u'^[0-9]+-([0-9]|K)$']]
    def validate_CdgIntRecepType(self, value):
        # Validate type CdgIntRecepType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CdgIntRecepType' % {"value" : value.encode("utf-8")} )
    def validate_RznSocLargaType(self, value):
        # Validate type RznSocLargaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RznSocLargaType' % {"value" : value.encode("utf-8")} )
    def validate_GiroRecepType(self, value):
        # Validate type GiroRecepType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GiroRecepType' % {"value" : value.encode("utf-8")} )
    def validate_ContactoType(self, value):
        # Validate type ContactoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ContactoType' % {"value" : value.encode("utf-8")} )
    def validate_MailType(self, value):
        # Validate type MailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on MailType' % {"value" : value.encode("utf-8")} )
    def validate_DirRecepType(self, value):
        # Validate type DirRecepType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DirRecepType' % {"value" : value.encode("utf-8")} )
    def validate_ComunaType(self, value):
        # Validate type ComunaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ComunaType' % {"value" : value.encode("utf-8")} )
    def validate_CiudadType(self, value):
        # Validate type CiudadType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CiudadType' % {"value" : value.encode("utf-8")} )
    def validate_DirPostalType(self, value):
        # Validate type DirPostalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DirPostalType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RUTRecep is not None or
            self.CdgIntRecep is not None or
            self.RznSocRecep is not None or
            self.Extranjero is not None or
            self.GiroRecep is not None or
            self.Contacto is not None or
            self.CorreoRecep is not None or
            self.DirRecep is not None or
            self.CmnaRecep is not None or
            self.CiudadRecep is not None or
            self.DirPostal is not None or
            self.CmnaPostal is not None or
            self.CiudadPostal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReceptorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReceptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReceptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ReceptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ReceptorType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReceptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RUTRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RUTRecep>%s</SiiDte:RUTRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RUTRecep), input_name='RUTRecep')), eol_))
        if self.CdgIntRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CdgIntRecep>%s</SiiDte:CdgIntRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CdgIntRecep), input_name='CdgIntRecep')), eol_))
        if self.RznSocRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RznSocRecep>%s</SiiDte:RznSocRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RznSocRecep), input_name='RznSocRecep')), eol_))
        if self.Extranjero is not None:
            self.Extranjero.export(outfile, level, namespaceprefix_, name_='Extranjero', pretty_print=pretty_print)
        if self.GiroRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GiroRecep>%s</SiiDte:GiroRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GiroRecep), input_name='GiroRecep')), eol_))
        if self.Contacto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Contacto>%s</SiiDte:Contacto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Contacto), input_name='Contacto')), eol_))
        if self.CorreoRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CorreoRecep>%s</SiiDte:CorreoRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CorreoRecep), input_name='CorreoRecep')), eol_))
        if self.DirRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DirRecep>%s</SiiDte:DirRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DirRecep), input_name='DirRecep')), eol_))
        if self.CmnaRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CmnaRecep>%s</SiiDte:CmnaRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CmnaRecep), input_name='CmnaRecep')), eol_))
        if self.CiudadRecep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CiudadRecep>%s</SiiDte:CiudadRecep>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CiudadRecep), input_name='CiudadRecep')), eol_))
        if self.DirPostal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DirPostal>%s</SiiDte:DirPostal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DirPostal), input_name='DirPostal')), eol_))
        if self.CmnaPostal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CmnaPostal>%s</SiiDte:CmnaPostal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CmnaPostal), input_name='CmnaPostal')), eol_))
        if self.CiudadPostal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CiudadPostal>%s</SiiDte:CiudadPostal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CiudadPostal), input_name='CiudadPostal')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUTRecep':
            RUTRecep_ = child_.text
            RUTRecep_ = self.gds_validate_string(RUTRecep_, node, 'RUTRecep')
            self.RUTRecep = RUTRecep_
            # validate type RUTType
            self.validate_RUTType(self.RUTRecep)
        elif nodeName_ == 'CdgIntRecep':
            CdgIntRecep_ = child_.text
            CdgIntRecep_ = self.gds_validate_string(CdgIntRecep_, node, 'CdgIntRecep')
            self.CdgIntRecep = CdgIntRecep_
            # validate type CdgIntRecepType
            self.validate_CdgIntRecepType(self.CdgIntRecep)
        elif nodeName_ == 'RznSocRecep':
            RznSocRecep_ = child_.text
            RznSocRecep_ = self.gds_validate_string(RznSocRecep_, node, 'RznSocRecep')
            self.RznSocRecep = RznSocRecep_
            # validate type RznSocLargaType
            self.validate_RznSocLargaType(self.RznSocRecep)
        elif nodeName_ == 'Extranjero':
            obj_ = ExtranjeroType.factory()
            obj_.build(child_)
            self.Extranjero = obj_
            obj_.original_tagname_ = 'Extranjero'
        elif nodeName_ == 'GiroRecep':
            GiroRecep_ = child_.text
            GiroRecep_ = self.gds_validate_string(GiroRecep_, node, 'GiroRecep')
            self.GiroRecep = GiroRecep_
            # validate type GiroRecepType
            self.validate_GiroRecepType(self.GiroRecep)
        elif nodeName_ == 'Contacto':
            Contacto_ = child_.text
            Contacto_ = self.gds_validate_string(Contacto_, node, 'Contacto')
            self.Contacto = Contacto_
            # validate type ContactoType
            self.validate_ContactoType(self.Contacto)
        elif nodeName_ == 'CorreoRecep':
            CorreoRecep_ = child_.text
            CorreoRecep_ = self.gds_validate_string(CorreoRecep_, node, 'CorreoRecep')
            self.CorreoRecep = CorreoRecep_
            # validate type MailType
            self.validate_MailType(self.CorreoRecep)
        elif nodeName_ == 'DirRecep':
            DirRecep_ = child_.text
            DirRecep_ = self.gds_validate_string(DirRecep_, node, 'DirRecep')
            self.DirRecep = DirRecep_
            # validate type DirRecepType
            self.validate_DirRecepType(self.DirRecep)
        elif nodeName_ == 'CmnaRecep':
            CmnaRecep_ = child_.text
            CmnaRecep_ = self.gds_validate_string(CmnaRecep_, node, 'CmnaRecep')
            self.CmnaRecep = CmnaRecep_
            # validate type ComunaType
            self.validate_ComunaType(self.CmnaRecep)
        elif nodeName_ == 'CiudadRecep':
            CiudadRecep_ = child_.text
            CiudadRecep_ = self.gds_validate_string(CiudadRecep_, node, 'CiudadRecep')
            self.CiudadRecep = CiudadRecep_
            # validate type CiudadType
            self.validate_CiudadType(self.CiudadRecep)
        elif nodeName_ == 'DirPostal':
            DirPostal_ = child_.text
            DirPostal_ = self.gds_validate_string(DirPostal_, node, 'DirPostal')
            self.DirPostal = DirPostal_
            # validate type DirPostalType
            self.validate_DirPostalType(self.DirPostal)
        elif nodeName_ == 'CmnaPostal':
            CmnaPostal_ = child_.text
            CmnaPostal_ = self.gds_validate_string(CmnaPostal_, node, 'CmnaPostal')
            self.CmnaPostal = CmnaPostal_
            # validate type ComunaType
            self.validate_ComunaType(self.CmnaPostal)
        elif nodeName_ == 'CiudadPostal':
            CiudadPostal_ = child_.text
            CiudadPostal_ = self.gds_validate_string(CiudadPostal_, node, 'CiudadPostal')
            self.CiudadPostal = CiudadPostal_
            # validate type CiudadType
            self.validate_CiudadType(self.CiudadPostal)
# end class ReceptorType


class ExtranjeroType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumId=None, Nacionalidad=None):
        self.original_tagname_ = None
        self.NumId = NumId
        self.validate_NumIdType(self.NumId)
        self.Nacionalidad = Nacionalidad
        self.validate_NacionalidadType(self.Nacionalidad)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtranjeroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtranjeroType.subclass:
            return ExtranjeroType.subclass(*args_, **kwargs_)
        else:
            return ExtranjeroType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumId(self): return self.NumId
    def set_NumId(self, NumId): self.NumId = NumId
    def get_Nacionalidad(self): return self.Nacionalidad
    def set_Nacionalidad(self, Nacionalidad): self.Nacionalidad = Nacionalidad
    def validate_NumIdType(self, value):
        # Validate type NumIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on NumIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NumIdType' % {"value" : value.encode("utf-8")} )
    def validate_NacionalidadType(self, value):
        # Validate type NacionalidadType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on NacionalidadType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on NacionalidadType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NumId is not None or
            self.Nacionalidad is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ExtranjeroType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtranjeroType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtranjeroType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ExtranjeroType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ExtranjeroType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ExtranjeroType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NumId>%s</SiiDte:NumId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumId), input_name='NumId')), eol_))
        if self.Nacionalidad is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Nacionalidad>%s</SiiDte:Nacionalidad>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Nacionalidad), input_name='Nacionalidad')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumId':
            NumId_ = child_.text
            NumId_ = self.gds_validate_string(NumId_, node, 'NumId')
            self.NumId = NumId_
            # validate type NumIdType
            self.validate_NumIdType(self.NumId)
        elif nodeName_ == 'Nacionalidad':
            Nacionalidad_ = child_.text
            Nacionalidad_ = self.gds_validate_string(Nacionalidad_, node, 'Nacionalidad')
            self.Nacionalidad = Nacionalidad_
            # validate type NacionalidadType
            self.validate_NacionalidadType(self.Nacionalidad)
# end class ExtranjeroType


class TotalesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MntNeto=None, MntExe=None, MntBase=None, MntMargenCom=None, TasaIVA=None, IVA=None, IVAProp=None, IVATerc=None, ImptoReten=None, IVANoRet=None, CredEC=None, GrntDep=None, Comisiones=None, MntTotal=None, MontoNF=None, MontoPeriodo=None, SaldoAnterior=None, VlrPagar=None):
        self.original_tagname_ = None
        self.MntNeto = MntNeto
        self.validate_MontoType(self.MntNeto)
        self.MntExe = MntExe
        self.validate_MontoType(self.MntExe)
        self.MntBase = MntBase
        self.validate_MontoType(self.MntBase)
        self.MntMargenCom = MntMargenCom
        self.validate_MontoType(self.MntMargenCom)
        self.TasaIVA = TasaIVA
        self.validate_PctType(self.TasaIVA)
        self.IVA = IVA
        self.validate_MontoType(self.IVA)
        self.IVAProp = IVAProp
        self.validate_MontoType(self.IVAProp)
        self.IVATerc = IVATerc
        self.validate_MontoType(self.IVATerc)
        if ImptoReten is None:
            self.ImptoReten = []
        else:
            self.ImptoReten = ImptoReten
        self.IVANoRet = IVANoRet
        self.validate_MntImpType(self.IVANoRet)
        self.CredEC = CredEC
        self.validate_MontoType(self.CredEC)
        self.GrntDep = GrntDep
        self.validate_MontoType(self.GrntDep)
        self.Comisiones = Comisiones
        self.MntTotal = MntTotal
        self.validate_MontoType(self.MntTotal)
        self.MontoNF = MontoNF
        self.validate_ValorType(self.MontoNF)
        self.MontoPeriodo = MontoPeriodo
        self.validate_ValorType(self.MontoPeriodo)
        self.SaldoAnterior = SaldoAnterior
        self.validate_ValorType(self.SaldoAnterior)
        self.VlrPagar = VlrPagar
        self.validate_ValorType(self.VlrPagar)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TotalesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TotalesType.subclass:
            return TotalesType.subclass(*args_, **kwargs_)
        else:
            return TotalesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MntNeto(self): return self.MntNeto
    def set_MntNeto(self, MntNeto): self.MntNeto = MntNeto
    def get_MntExe(self): return self.MntExe
    def set_MntExe(self, MntExe): self.MntExe = MntExe
    def get_MntBase(self): return self.MntBase
    def set_MntBase(self, MntBase): self.MntBase = MntBase
    def get_MntMargenCom(self): return self.MntMargenCom
    def set_MntMargenCom(self, MntMargenCom): self.MntMargenCom = MntMargenCom
    def get_TasaIVA(self): return self.TasaIVA
    def set_TasaIVA(self, TasaIVA): self.TasaIVA = TasaIVA
    def get_IVA(self): return self.IVA
    def set_IVA(self, IVA): self.IVA = IVA
    def get_IVAProp(self): return self.IVAProp
    def set_IVAProp(self, IVAProp): self.IVAProp = IVAProp
    def get_IVATerc(self): return self.IVATerc
    def set_IVATerc(self, IVATerc): self.IVATerc = IVATerc
    def get_ImptoReten(self): return self.ImptoReten
    def set_ImptoReten(self, ImptoReten): self.ImptoReten = ImptoReten
    def add_ImptoReten(self, value): self.ImptoReten.append(value)
    def insert_ImptoReten_at(self, index, value): self.ImptoReten.insert(index, value)
    def replace_ImptoReten_at(self, index, value): self.ImptoReten[index] = value
    def get_IVANoRet(self): return self.IVANoRet
    def set_IVANoRet(self, IVANoRet): self.IVANoRet = IVANoRet
    def get_CredEC(self): return self.CredEC
    def set_CredEC(self, CredEC): self.CredEC = CredEC
    def get_GrntDep(self): return self.GrntDep
    def set_GrntDep(self, GrntDep): self.GrntDep = GrntDep
    def get_Comisiones(self): return self.Comisiones
    def set_Comisiones(self, Comisiones): self.Comisiones = Comisiones
    def get_MntTotal(self): return self.MntTotal
    def set_MntTotal(self, MntTotal): self.MntTotal = MntTotal
    def get_MontoNF(self): return self.MontoNF
    def set_MontoNF(self, MontoNF): self.MontoNF = MontoNF
    def get_MontoPeriodo(self): return self.MontoPeriodo
    def set_MontoPeriodo(self, MontoPeriodo): self.MontoPeriodo = MontoPeriodo
    def get_SaldoAnterior(self): return self.SaldoAnterior
    def set_SaldoAnterior(self, SaldoAnterior): self.SaldoAnterior = SaldoAnterior
    def get_VlrPagar(self): return self.VlrPagar
    def set_VlrPagar(self, VlrPagar): self.VlrPagar = VlrPagar
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def validate_PctType(self, value):
        # Validate type PctType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PctType' % {"value" : value} )
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
    def validate_MntImpType(self, value):
        # Validate type MntImpType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MntImpType' % {"value" : value} )
    def validate_ValorType(self, value):
        # Validate type ValorType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ValorType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.MntNeto is not None or
            self.MntExe is not None or
            self.MntBase is not None or
            self.MntMargenCom is not None or
            self.TasaIVA is not None or
            self.IVA is not None or
            self.IVAProp is not None or
            self.IVATerc is not None or
            self.ImptoReten or
            self.IVANoRet is not None or
            self.CredEC is not None or
            self.GrntDep is not None or
            self.Comisiones is not None or
            self.MntTotal is not None or
            self.MontoNF is not None or
            self.MontoPeriodo is not None or
            self.SaldoAnterior is not None or
            self.VlrPagar is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='TotalesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TotalesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TotalesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='TotalesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='TotalesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='TotalesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MntNeto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntNeto>%s</SiiDte:MntNeto>%s' % (self.gds_format_integer(self.MntNeto, input_name='MntNeto'), eol_))
        if self.MntExe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntExe>%s</SiiDte:MntExe>%s' % (self.gds_format_integer(self.MntExe, input_name='MntExe'), eol_))
        if self.MntBase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntBase>%s</SiiDte:MntBase>%s' % (self.gds_format_integer(self.MntBase, input_name='MntBase'), eol_))
        if self.MntMargenCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntMargenCom>%s</SiiDte:MntMargenCom>%s' % (self.gds_format_integer(self.MntMargenCom, input_name='MntMargenCom'), eol_))
        if self.TasaIVA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TasaIVA>%s</SiiDte:TasaIVA>%s' % (self.gds_format_float(self.TasaIVA, input_name='TasaIVA'), eol_))
        if self.IVA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVA>%s</SiiDte:IVA>%s' % (self.gds_format_integer(self.IVA, input_name='IVA'), eol_))
        if self.IVAProp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVAProp>%s</SiiDte:IVAProp>%s' % (self.gds_format_integer(self.IVAProp, input_name='IVAProp'), eol_))
        if self.IVATerc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVATerc>%s</SiiDte:IVATerc>%s' % (self.gds_format_integer(self.IVATerc, input_name='IVATerc'), eol_))
        for ImptoReten_ in self.ImptoReten:
            ImptoReten_.export(outfile, level, namespaceprefix_, name_='ImptoReten', pretty_print=pretty_print)
        if self.IVANoRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVANoRet>%s</SiiDte:IVANoRet>%s' % (self.gds_format_integer(self.IVANoRet, input_name='IVANoRet'), eol_))
        if self.CredEC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CredEC>%s</SiiDte:CredEC>%s' % (self.gds_format_integer(self.CredEC, input_name='CredEC'), eol_))
        if self.GrntDep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GrntDep>%s</SiiDte:GrntDep>%s' % (self.gds_format_integer(self.GrntDep, input_name='GrntDep'), eol_))
        if self.Comisiones is not None:
            self.Comisiones.export(outfile, level, namespaceprefix_, name_='Comisiones', pretty_print=pretty_print)
        if self.MntTotal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntTotal>%s</SiiDte:MntTotal>%s' % (self.gds_format_integer(self.MntTotal, input_name='MntTotal'), eol_))
        if self.MontoNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MontoNF>%s</SiiDte:MontoNF>%s' % (self.gds_format_integer(self.MontoNF, input_name='MontoNF'), eol_))
        if self.MontoPeriodo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MontoPeriodo>%s</SiiDte:MontoPeriodo>%s' % (self.gds_format_integer(self.MontoPeriodo, input_name='MontoPeriodo'), eol_))
        if self.SaldoAnterior is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SaldoAnterior>%s</SiiDte:SaldoAnterior>%s' % (self.gds_format_integer(self.SaldoAnterior, input_name='SaldoAnterior'), eol_))
        if self.VlrPagar is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:VlrPagar>%s</SiiDte:VlrPagar>%s' % (self.gds_format_integer(self.VlrPagar, input_name='VlrPagar'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MntNeto' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntNeto')
            self.MntNeto = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntNeto)
        elif nodeName_ == 'MntExe' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntExe')
            self.MntExe = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntExe)
        elif nodeName_ == 'MntBase' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntBase')
            self.MntBase = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntBase)
        elif nodeName_ == 'MntMargenCom' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntMargenCom')
            self.MntMargenCom = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntMargenCom)
        elif nodeName_ == 'TasaIVA' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TasaIVA')
            self.TasaIVA = fval_
            # validate type PctType
            self.validate_PctType(self.TasaIVA)
        elif nodeName_ == 'IVA' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IVA')
            self.IVA = ival_
            # validate type MontoType
            self.validate_MontoType(self.IVA)
        elif nodeName_ == 'IVAProp' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IVAProp')
            self.IVAProp = ival_
            # validate type MontoType
            self.validate_MontoType(self.IVAProp)
        elif nodeName_ == 'IVATerc' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IVATerc')
            self.IVATerc = ival_
            # validate type MontoType
            self.validate_MontoType(self.IVATerc)
        elif nodeName_ == 'ImptoReten':
            obj_ = ImptoRetenType.factory()
            obj_.build(child_)
            self.ImptoReten.append(obj_)
            obj_.original_tagname_ = 'ImptoReten'
        elif nodeName_ == 'IVANoRet' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IVANoRet')
            self.IVANoRet = ival_
            # validate type MntImpType
            self.validate_MntImpType(self.IVANoRet)
        elif nodeName_ == 'CredEC' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CredEC')
            self.CredEC = ival_
            # validate type MontoType
            self.validate_MontoType(self.CredEC)
        elif nodeName_ == 'GrntDep' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'GrntDep')
            self.GrntDep = ival_
            # validate type MontoType
            self.validate_MontoType(self.GrntDep)
        elif nodeName_ == 'Comisiones':
            obj_ = ComisionesType.factory()
            obj_.build(child_)
            self.Comisiones = obj_
            obj_.original_tagname_ = 'Comisiones'
        elif nodeName_ == 'MntTotal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntTotal')
            self.MntTotal = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntTotal)
        elif nodeName_ == 'MontoNF' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MontoNF')
            self.MontoNF = ival_
            # validate type ValorType
            self.validate_ValorType(self.MontoNF)
        elif nodeName_ == 'MontoPeriodo' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MontoPeriodo')
            self.MontoPeriodo = ival_
            # validate type ValorType
            self.validate_ValorType(self.MontoPeriodo)
        elif nodeName_ == 'SaldoAnterior' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SaldoAnterior')
            self.SaldoAnterior = ival_
            # validate type ValorType
            self.validate_ValorType(self.SaldoAnterior)
        elif nodeName_ == 'VlrPagar' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VlrPagar')
            self.VlrPagar = ival_
            # validate type ValorType
            self.validate_ValorType(self.VlrPagar)
# end class TotalesType


class ImptoRetenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TipoImp=None, TasaImp=None, MontoImp=None):
        self.original_tagname_ = None
        self.TipoImp = TipoImp
        self.validate_ImpAdicDTEType(self.TipoImp)
        self.TasaImp = TasaImp
        self.validate_TasaImpType(self.TasaImp)
        self.MontoImp = MontoImp
        self.validate_MntImpType(self.MontoImp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImptoRetenType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImptoRetenType.subclass:
            return ImptoRetenType.subclass(*args_, **kwargs_)
        else:
            return ImptoRetenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoImp(self): return self.TipoImp
    def set_TipoImp(self, TipoImp): self.TipoImp = TipoImp
    def get_TasaImp(self): return self.TasaImp
    def set_TasaImp(self, TasaImp): self.TasaImp = TasaImp
    def get_MontoImp(self): return self.MontoImp
    def set_MontoImp(self, MontoImp): self.MontoImp = MontoImp
    def validate_ImpAdicDTEType(self, value):
        # Validate type ImpAdicDTEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['14', '15', '16', '17', '18', '19', '23', '24', '25', '26', '27', '28', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '271', '301', '321', '331', '341', '361', '371', '481']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
    def validate_TasaImpType(self, value):
        # Validate type TasaImpType, a restriction on SiiDte:PctType.
        if value is not None and Validate_simpletypes_:
            if value > 100.00:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TasaImpType' % {"value" : value} )
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TasaImpType' % {"value" : value} )
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TasaImpType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TasaImpType' % {"value" : value} )
    def validate_MntImpType(self, value):
        # Validate type MntImpType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MntImpType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoImp is not None or
            self.TasaImp is not None or
            self.MontoImp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ImptoRetenType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImptoRetenType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImptoRetenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ImptoRetenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ImptoRetenType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ImptoRetenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoImp>%s</SiiDte:TipoImp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoImp), input_name='TipoImp')), eol_))
        if self.TasaImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TasaImp>%s</SiiDte:TasaImp>%s' % (self.gds_format_float(self.TasaImp, input_name='TasaImp'), eol_))
        if self.MontoImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MontoImp>%s</SiiDte:MontoImp>%s' % (self.gds_format_integer(self.MontoImp, input_name='MontoImp'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoImp':
            TipoImp_ = child_.text
            TipoImp_ = self.gds_validate_string(TipoImp_, node, 'TipoImp')
            self.TipoImp = TipoImp_
            # validate type ImpAdicDTEType
            self.validate_ImpAdicDTEType(self.TipoImp)
        elif nodeName_ == 'TasaImp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TasaImp')
            self.TasaImp = fval_
            # validate type TasaImpType
            self.validate_TasaImpType(self.TasaImp)
        elif nodeName_ == 'MontoImp' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MontoImp')
            self.MontoImp = ival_
            # validate type MntImpType
            self.validate_MntImpType(self.MontoImp)
# end class ImptoRetenType


class ComisionesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValComNeto=None, ValComExe=None, ValComIVA=None):
        self.original_tagname_ = None
        self.ValComNeto = ValComNeto
        self.validate_MontoType(self.ValComNeto)
        self.ValComExe = ValComExe
        self.validate_MontoType(self.ValComExe)
        self.ValComIVA = ValComIVA
        self.validate_MontoType(self.ValComIVA)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComisionesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComisionesType.subclass:
            return ComisionesType.subclass(*args_, **kwargs_)
        else:
            return ComisionesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValComNeto(self): return self.ValComNeto
    def set_ValComNeto(self, ValComNeto): self.ValComNeto = ValComNeto
    def get_ValComExe(self): return self.ValComExe
    def set_ValComExe(self, ValComExe): self.ValComExe = ValComExe
    def get_ValComIVA(self): return self.ValComIVA
    def set_ValComIVA(self, ValComIVA): self.ValComIVA = ValComIVA
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ValComNeto is not None or
            self.ValComExe is not None or
            self.ValComIVA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ComisionesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComisionesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComisionesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ComisionesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ComisionesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ComisionesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ValComNeto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValComNeto>%s</SiiDte:ValComNeto>%s' % (self.gds_format_integer(self.ValComNeto, input_name='ValComNeto'), eol_))
        if self.ValComExe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValComExe>%s</SiiDte:ValComExe>%s' % (self.gds_format_integer(self.ValComExe, input_name='ValComExe'), eol_))
        if self.ValComIVA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValComIVA>%s</SiiDte:ValComIVA>%s' % (self.gds_format_integer(self.ValComIVA, input_name='ValComIVA'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValComNeto' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ValComNeto')
            self.ValComNeto = ival_
            # validate type MontoType
            self.validate_MontoType(self.ValComNeto)
        elif nodeName_ == 'ValComExe' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ValComExe')
            self.ValComExe = ival_
            # validate type MontoType
            self.validate_MontoType(self.ValComExe)
        elif nodeName_ == 'ValComIVA' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ValComIVA')
            self.ValComIVA = ival_
            # validate type MontoType
            self.validate_MontoType(self.ValComIVA)
# end class ComisionesType


class OtraMonedaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TpoMoneda=None, TpoCambio=None, MntNetoOtrMnda=None, MntExeOtrMnda=None, MntFaeCarneOtrMnda=None, MntMargComOtrMnda=None, IVAOtrMnda=None, ImpRetOtrMnda=None, IVANoRetOtrMnda=None, MntTotOtrMnda=None):
        self.original_tagname_ = None
        self.TpoMoneda = TpoMoneda
        self.validate_TipMonType(self.TpoMoneda)
        self.TpoCambio = TpoCambio
        self.validate_Dec6_4Type(self.TpoCambio)
        self.MntNetoOtrMnda = MntNetoOtrMnda
        self.validate_Dec14_4Type(self.MntNetoOtrMnda)
        self.MntExeOtrMnda = MntExeOtrMnda
        self.validate_Dec14_4Type(self.MntExeOtrMnda)
        self.MntFaeCarneOtrMnda = MntFaeCarneOtrMnda
        self.validate_Dec14_4Type(self.MntFaeCarneOtrMnda)
        self.MntMargComOtrMnda = MntMargComOtrMnda
        self.validate_Dec14_4Type(self.MntMargComOtrMnda)
        self.IVAOtrMnda = IVAOtrMnda
        self.validate_Dec14_4Type(self.IVAOtrMnda)
        if ImpRetOtrMnda is None:
            self.ImpRetOtrMnda = []
        else:
            self.ImpRetOtrMnda = ImpRetOtrMnda
        self.IVANoRetOtrMnda = IVANoRetOtrMnda
        self.validate_Dec14_4Type(self.IVANoRetOtrMnda)
        self.MntTotOtrMnda = MntTotOtrMnda
        self.validate_Dec14_4Type(self.MntTotOtrMnda)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtraMonedaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtraMonedaType.subclass:
            return OtraMonedaType.subclass(*args_, **kwargs_)
        else:
            return OtraMonedaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TpoMoneda(self): return self.TpoMoneda
    def set_TpoMoneda(self, TpoMoneda): self.TpoMoneda = TpoMoneda
    def get_TpoCambio(self): return self.TpoCambio
    def set_TpoCambio(self, TpoCambio): self.TpoCambio = TpoCambio
    def get_MntNetoOtrMnda(self): return self.MntNetoOtrMnda
    def set_MntNetoOtrMnda(self, MntNetoOtrMnda): self.MntNetoOtrMnda = MntNetoOtrMnda
    def get_MntExeOtrMnda(self): return self.MntExeOtrMnda
    def set_MntExeOtrMnda(self, MntExeOtrMnda): self.MntExeOtrMnda = MntExeOtrMnda
    def get_MntFaeCarneOtrMnda(self): return self.MntFaeCarneOtrMnda
    def set_MntFaeCarneOtrMnda(self, MntFaeCarneOtrMnda): self.MntFaeCarneOtrMnda = MntFaeCarneOtrMnda
    def get_MntMargComOtrMnda(self): return self.MntMargComOtrMnda
    def set_MntMargComOtrMnda(self, MntMargComOtrMnda): self.MntMargComOtrMnda = MntMargComOtrMnda
    def get_IVAOtrMnda(self): return self.IVAOtrMnda
    def set_IVAOtrMnda(self, IVAOtrMnda): self.IVAOtrMnda = IVAOtrMnda
    def get_ImpRetOtrMnda(self): return self.ImpRetOtrMnda
    def set_ImpRetOtrMnda(self, ImpRetOtrMnda): self.ImpRetOtrMnda = ImpRetOtrMnda
    def add_ImpRetOtrMnda(self, value): self.ImpRetOtrMnda.append(value)
    def insert_ImpRetOtrMnda_at(self, index, value): self.ImpRetOtrMnda.insert(index, value)
    def replace_ImpRetOtrMnda_at(self, index, value): self.ImpRetOtrMnda[index] = value
    def get_IVANoRetOtrMnda(self): return self.IVANoRetOtrMnda
    def set_IVANoRetOtrMnda(self, IVANoRetOtrMnda): self.IVANoRetOtrMnda = IVANoRetOtrMnda
    def get_MntTotOtrMnda(self): return self.MntTotOtrMnda
    def set_MntTotOtrMnda(self, MntTotOtrMnda): self.MntTotOtrMnda = MntTotOtrMnda
    def validate_TipMonType(self, value):
        # Validate type TipMonType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BOLIVAR', 'BOLIVIANO', 'CHELIN', 'CORONA DIN', 'CORONA NOR', 'CORONA SC', 'CRUZEIRO REAL', 'DIRHAM', 'DOLAR AUST', 'DOLAR CAN', 'DOLAR HK', 'DOLAR NZ', 'DOLAR SIN', 'DOLAR TAI', 'DOLAR USA', 'DRACMA', 'ESCUDO', 'EURO', 'FLORIN', 'FRANCO BEL', 'FRANCO FR', 'FRANCO SZ', 'GUARANI', 'LIBRA EST', 'LIRA', 'MARCO AL', 'MARCO FIN', 'NUEVO SOL', 'OTRAS MONEDAS', 'PESETA', 'PESO', 'PESO CL', 'PESO COL', 'PESO MEX', 'PESO URUG', 'RAND', 'RENMINBI', 'RUPIA', 'SUCRE', 'YEN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TipMonType' % {"value" : value.encode("utf-8")} )
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TipMonType' % {"value" : value.encode("utf-8")} )
    def validate_Dec6_4Type(self, value):
        # Validate type Dec6_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec6_4Type' % {"value" : value} )
            if value > 999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec6_4Type' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec6_4Type' % {"value" : value} )
    def validate_Dec14_4Type(self, value):
        # Validate type Dec14_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec14_4Type' % {"value" : value} )
            if value > 99999999999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TpoMoneda is not None or
            self.TpoCambio is not None or
            self.MntNetoOtrMnda is not None or
            self.MntExeOtrMnda is not None or
            self.MntFaeCarneOtrMnda is not None or
            self.MntMargComOtrMnda is not None or
            self.IVAOtrMnda is not None or
            self.ImpRetOtrMnda or
            self.IVANoRetOtrMnda is not None or
            self.MntTotOtrMnda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='OtraMonedaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtraMonedaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtraMonedaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='OtraMonedaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='OtraMonedaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='OtraMonedaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TpoMoneda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoMoneda>%s</SiiDte:TpoMoneda>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoMoneda), input_name='TpoMoneda')), eol_))
        if self.TpoCambio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoCambio>%s</SiiDte:TpoCambio>%s' % (self.gds_format_float(self.TpoCambio, input_name='TpoCambio'), eol_))
        if self.MntNetoOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntNetoOtrMnda>%s</SiiDte:MntNetoOtrMnda>%s' % (self.gds_format_float(self.MntNetoOtrMnda, input_name='MntNetoOtrMnda'), eol_))
        if self.MntExeOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntExeOtrMnda>%s</SiiDte:MntExeOtrMnda>%s' % (self.gds_format_float(self.MntExeOtrMnda, input_name='MntExeOtrMnda'), eol_))
        if self.MntFaeCarneOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntFaeCarneOtrMnda>%s</SiiDte:MntFaeCarneOtrMnda>%s' % (self.gds_format_float(self.MntFaeCarneOtrMnda, input_name='MntFaeCarneOtrMnda'), eol_))
        if self.MntMargComOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntMargComOtrMnda>%s</SiiDte:MntMargComOtrMnda>%s' % (self.gds_format_float(self.MntMargComOtrMnda, input_name='MntMargComOtrMnda'), eol_))
        if self.IVAOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVAOtrMnda>%s</SiiDte:IVAOtrMnda>%s' % (self.gds_format_float(self.IVAOtrMnda, input_name='IVAOtrMnda'), eol_))
        for ImpRetOtrMnda_ in self.ImpRetOtrMnda:
            ImpRetOtrMnda_.export(outfile, level, namespaceprefix_, name_='ImpRetOtrMnda', pretty_print=pretty_print)
        if self.IVANoRetOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IVANoRetOtrMnda>%s</SiiDte:IVANoRetOtrMnda>%s' % (self.gds_format_float(self.IVANoRetOtrMnda, input_name='IVANoRetOtrMnda'), eol_))
        if self.MntTotOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntTotOtrMnda>%s</SiiDte:MntTotOtrMnda>%s' % (self.gds_format_float(self.MntTotOtrMnda, input_name='MntTotOtrMnda'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TpoMoneda':
            TpoMoneda_ = child_.text
            TpoMoneda_ = self.gds_validate_string(TpoMoneda_, node, 'TpoMoneda')
            self.TpoMoneda = TpoMoneda_
            # validate type TipMonType
            self.validate_TipMonType(self.TpoMoneda)
        elif nodeName_ == 'TpoCambio' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TpoCambio')
            self.TpoCambio = fval_
            # validate type Dec6_4Type
            self.validate_Dec6_4Type(self.TpoCambio)
        elif nodeName_ == 'MntNetoOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MntNetoOtrMnda')
            self.MntNetoOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MntNetoOtrMnda)
        elif nodeName_ == 'MntExeOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MntExeOtrMnda')
            self.MntExeOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MntExeOtrMnda)
        elif nodeName_ == 'MntFaeCarneOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MntFaeCarneOtrMnda')
            self.MntFaeCarneOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MntFaeCarneOtrMnda)
        elif nodeName_ == 'MntMargComOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MntMargComOtrMnda')
            self.MntMargComOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MntMargComOtrMnda)
        elif nodeName_ == 'IVAOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'IVAOtrMnda')
            self.IVAOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.IVAOtrMnda)
        elif nodeName_ == 'ImpRetOtrMnda':
            obj_ = ImpRetOtrMndaType.factory()
            obj_.build(child_)
            self.ImpRetOtrMnda.append(obj_)
            obj_.original_tagname_ = 'ImpRetOtrMnda'
        elif nodeName_ == 'IVANoRetOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'IVANoRetOtrMnda')
            self.IVANoRetOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.IVANoRetOtrMnda)
        elif nodeName_ == 'MntTotOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MntTotOtrMnda')
            self.MntTotOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MntTotOtrMnda)
# end class OtraMonedaType


class ImpRetOtrMndaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TipoImpOtrMnda=None, TasaImpOtrMnda=None, VlrImpOtrMnda=None):
        self.original_tagname_ = None
        self.TipoImpOtrMnda = TipoImpOtrMnda
        self.validate_ImpAdicDTEType(self.TipoImpOtrMnda)
        self.TasaImpOtrMnda = TasaImpOtrMnda
        self.validate_PctType(self.TasaImpOtrMnda)
        self.VlrImpOtrMnda = VlrImpOtrMnda
        self.validate_Dec14_4Type(self.VlrImpOtrMnda)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpRetOtrMndaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpRetOtrMndaType.subclass:
            return ImpRetOtrMndaType.subclass(*args_, **kwargs_)
        else:
            return ImpRetOtrMndaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoImpOtrMnda(self): return self.TipoImpOtrMnda
    def set_TipoImpOtrMnda(self, TipoImpOtrMnda): self.TipoImpOtrMnda = TipoImpOtrMnda
    def get_TasaImpOtrMnda(self): return self.TasaImpOtrMnda
    def set_TasaImpOtrMnda(self, TasaImpOtrMnda): self.TasaImpOtrMnda = TasaImpOtrMnda
    def get_VlrImpOtrMnda(self): return self.VlrImpOtrMnda
    def set_VlrImpOtrMnda(self, VlrImpOtrMnda): self.VlrImpOtrMnda = VlrImpOtrMnda
    def validate_ImpAdicDTEType(self, value):
        # Validate type ImpAdicDTEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['14', '15', '16', '17', '18', '19', '23', '24', '25', '26', '27', '28', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '271', '301', '321', '331', '341', '361', '371', '481']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
    def validate_PctType(self, value):
        # Validate type PctType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PctType' % {"value" : value} )
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
    def validate_Dec14_4Type(self, value):
        # Validate type Dec14_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec14_4Type' % {"value" : value} )
            if value > 99999999999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoImpOtrMnda is not None or
            self.TasaImpOtrMnda is not None or
            self.VlrImpOtrMnda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ImpRetOtrMndaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImpRetOtrMndaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImpRetOtrMndaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ImpRetOtrMndaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ImpRetOtrMndaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ImpRetOtrMndaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoImpOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoImpOtrMnda>%s</SiiDte:TipoImpOtrMnda>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoImpOtrMnda), input_name='TipoImpOtrMnda')), eol_))
        if self.TasaImpOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TasaImpOtrMnda>%s</SiiDte:TasaImpOtrMnda>%s' % (self.gds_format_float(self.TasaImpOtrMnda, input_name='TasaImpOtrMnda'), eol_))
        if self.VlrImpOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:VlrImpOtrMnda>%s</SiiDte:VlrImpOtrMnda>%s' % (self.gds_format_float(self.VlrImpOtrMnda, input_name='VlrImpOtrMnda'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoImpOtrMnda':
            TipoImpOtrMnda_ = child_.text
            TipoImpOtrMnda_ = self.gds_validate_string(TipoImpOtrMnda_, node, 'TipoImpOtrMnda')
            self.TipoImpOtrMnda = TipoImpOtrMnda_
            # validate type ImpAdicDTEType
            self.validate_ImpAdicDTEType(self.TipoImpOtrMnda)
        elif nodeName_ == 'TasaImpOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TasaImpOtrMnda')
            self.TasaImpOtrMnda = fval_
            # validate type PctType
            self.validate_PctType(self.TasaImpOtrMnda)
        elif nodeName_ == 'VlrImpOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'VlrImpOtrMnda')
            self.VlrImpOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.VlrImpOtrMnda)
# end class ImpRetOtrMndaType


class DetalleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NroLinDet=None, CdgItem=None, IndExe=None, Retenedor=None, NmbItem=None, DscItem=None, QtyRef=None, UnmdRef=None, PrcRef=None, QtyItem=None, Subcantidad=None, FchElabor=None, FchVencim=None, UnmdItem=None, PrcItem=None, OtrMnda=None, DescuentoPct=None, DescuentoMonto=None, SubDscto=None, RecargoPct=None, RecargoMonto=None, SubRecargo=None, CodImpAdic=None, MontoItem=None):
        self.original_tagname_ = None
        self.NroLinDet = NroLinDet
        self.validate_NroLinDetType(self.NroLinDet)
        if CdgItem is None:
            self.CdgItem = []
        else:
            self.CdgItem = CdgItem
        self.IndExe = IndExe
        self.validate_IndExeType(self.IndExe)
        self.Retenedor = Retenedor
        self.NmbItem = NmbItem
        self.validate_NmbItemType(self.NmbItem)
        self.DscItem = DscItem
        self.validate_DscItemType(self.DscItem)
        self.QtyRef = QtyRef
        self.validate_Dec12_6Type(self.QtyRef)
        self.UnmdRef = UnmdRef
        self.validate_UnmdRefType(self.UnmdRef)
        self.PrcRef = PrcRef
        self.validate_Dec12_6Type(self.PrcRef)
        self.QtyItem = QtyItem
        self.validate_Dec12_6Type(self.QtyItem)
        if Subcantidad is None:
            self.Subcantidad = []
        else:
            self.Subcantidad = Subcantidad
        if isinstance(FchElabor, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchElabor, '%Y-%m-%d').date()
        else:
            initvalue_ = FchElabor
        self.FchElabor = initvalue_
        if isinstance(FchVencim, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchVencim, '%Y-%m-%d').date()
        else:
            initvalue_ = FchVencim
        self.FchVencim = initvalue_
        self.UnmdItem = UnmdItem
        self.validate_UnmdItemType(self.UnmdItem)
        self.PrcItem = PrcItem
        self.validate_Dec12_6Type(self.PrcItem)
        self.OtrMnda = OtrMnda
        self.DescuentoPct = DescuentoPct
        self.validate_PctType(self.DescuentoPct)
        self.DescuentoMonto = DescuentoMonto
        self.validate_MntImpType(self.DescuentoMonto)
        if SubDscto is None:
            self.SubDscto = []
        else:
            self.SubDscto = SubDscto
        self.RecargoPct = RecargoPct
        self.validate_RecargoPctType(self.RecargoPct)
        self.RecargoMonto = RecargoMonto
        self.validate_MntImpType(self.RecargoMonto)
        if SubRecargo is None:
            self.SubRecargo = []
        else:
            self.SubRecargo = SubRecargo
        if CodImpAdic is None:
            self.CodImpAdic = []
        else:
            self.CodImpAdic = CodImpAdic
        self.MontoItem = MontoItem
        self.validate_MontoType(self.MontoItem)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetalleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetalleType.subclass:
            return DetalleType.subclass(*args_, **kwargs_)
        else:
            return DetalleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NroLinDet(self): return self.NroLinDet
    def set_NroLinDet(self, NroLinDet): self.NroLinDet = NroLinDet
    def get_CdgItem(self): return self.CdgItem
    def set_CdgItem(self, CdgItem): self.CdgItem = CdgItem
    def add_CdgItem(self, value): self.CdgItem.append(value)
    def insert_CdgItem_at(self, index, value): self.CdgItem.insert(index, value)
    def replace_CdgItem_at(self, index, value): self.CdgItem[index] = value
    def get_IndExe(self): return self.IndExe
    def set_IndExe(self, IndExe): self.IndExe = IndExe
    def get_Retenedor(self): return self.Retenedor
    def set_Retenedor(self, Retenedor): self.Retenedor = Retenedor
    def get_NmbItem(self): return self.NmbItem
    def set_NmbItem(self, NmbItem): self.NmbItem = NmbItem
    def get_DscItem(self): return self.DscItem
    def set_DscItem(self, DscItem): self.DscItem = DscItem
    def get_QtyRef(self): return self.QtyRef
    def set_QtyRef(self, QtyRef): self.QtyRef = QtyRef
    def get_UnmdRef(self): return self.UnmdRef
    def set_UnmdRef(self, UnmdRef): self.UnmdRef = UnmdRef
    def get_PrcRef(self): return self.PrcRef
    def set_PrcRef(self, PrcRef): self.PrcRef = PrcRef
    def get_QtyItem(self): return self.QtyItem
    def set_QtyItem(self, QtyItem): self.QtyItem = QtyItem
    def get_Subcantidad(self): return self.Subcantidad
    def set_Subcantidad(self, Subcantidad): self.Subcantidad = Subcantidad
    def add_Subcantidad(self, value): self.Subcantidad.append(value)
    def insert_Subcantidad_at(self, index, value): self.Subcantidad.insert(index, value)
    def replace_Subcantidad_at(self, index, value): self.Subcantidad[index] = value
    def get_FchElabor(self): return self.FchElabor
    def set_FchElabor(self, FchElabor): self.FchElabor = FchElabor
    def get_FchVencim(self): return self.FchVencim
    def set_FchVencim(self, FchVencim): self.FchVencim = FchVencim
    def get_UnmdItem(self): return self.UnmdItem
    def set_UnmdItem(self, UnmdItem): self.UnmdItem = UnmdItem
    def get_PrcItem(self): return self.PrcItem
    def set_PrcItem(self, PrcItem): self.PrcItem = PrcItem
    def get_OtrMnda(self): return self.OtrMnda
    def set_OtrMnda(self, OtrMnda): self.OtrMnda = OtrMnda
    def get_DescuentoPct(self): return self.DescuentoPct
    def set_DescuentoPct(self, DescuentoPct): self.DescuentoPct = DescuentoPct
    def get_DescuentoMonto(self): return self.DescuentoMonto
    def set_DescuentoMonto(self, DescuentoMonto): self.DescuentoMonto = DescuentoMonto
    def get_SubDscto(self): return self.SubDscto
    def set_SubDscto(self, SubDscto): self.SubDscto = SubDscto
    def add_SubDscto(self, value): self.SubDscto.append(value)
    def insert_SubDscto_at(self, index, value): self.SubDscto.insert(index, value)
    def replace_SubDscto_at(self, index, value): self.SubDscto[index] = value
    def get_RecargoPct(self): return self.RecargoPct
    def set_RecargoPct(self, RecargoPct): self.RecargoPct = RecargoPct
    def get_RecargoMonto(self): return self.RecargoMonto
    def set_RecargoMonto(self, RecargoMonto): self.RecargoMonto = RecargoMonto
    def get_SubRecargo(self): return self.SubRecargo
    def set_SubRecargo(self, SubRecargo): self.SubRecargo = SubRecargo
    def add_SubRecargo(self, value): self.SubRecargo.append(value)
    def insert_SubRecargo_at(self, index, value): self.SubRecargo.insert(index, value)
    def replace_SubRecargo_at(self, index, value): self.SubRecargo[index] = value
    def get_CodImpAdic(self): return self.CodImpAdic
    def set_CodImpAdic(self, CodImpAdic): self.CodImpAdic = CodImpAdic
    def add_CodImpAdic(self, value): self.CodImpAdic.append(value)
    def insert_CodImpAdic_at(self, index, value): self.CodImpAdic.insert(index, value)
    def replace_CodImpAdic_at(self, index, value): self.CodImpAdic[index] = value
    def get_MontoItem(self): return self.MontoItem
    def set_MontoItem(self, MontoItem): self.MontoItem = MontoItem
    def validate_NroLinDetType(self, value):
        # Validate type NroLinDetType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NroLinDetType' % {"value" : value} )
    def validate_IndExeType(self, value):
        # Validate type IndExeType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndExeType' % {"value" : value.encode("utf-8")} )
    def validate_NmbItemType(self, value):
        # Validate type NmbItemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 80:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on NmbItemType' % {"value" : value.encode("utf-8")} )
    def validate_DscItemType(self, value):
        # Validate type DscItemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 1000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DscItemType' % {"value" : value.encode("utf-8")} )
    def validate_Dec12_6Type(self, value):
        # Validate type Dec12_6Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec12_6Type' % {"value" : value} )
            if value > 999999999999.999999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
    def validate_UnmdRefType(self, value):
        # Validate type UnmdRefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UnmdRefType' % {"value" : value.encode("utf-8")} )
    def validate_FechaType(self, value):
        # Validate type FechaType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_date('2000-01-01'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaType' % {"value" : value} )
            if value > self.gds_parse_date('2050-12-31'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaType' % {"value" : value} )
    def validate_UnmdItemType(self, value):
        # Validate type UnmdItemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on UnmdItemType' % {"value" : value.encode("utf-8")} )
    def validate_PctType(self, value):
        # Validate type PctType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PctType' % {"value" : value} )
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PctType' % {"value" : value} )
    def validate_MntImpType(self, value):
        # Validate type MntImpType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MntImpType' % {"value" : value} )
    def validate_RecargoPctType(self, value):
        # Validate type RecargoPctType, a restriction on SiiDte:PctType.
        if value is not None and Validate_simpletypes_:
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RecargoPctType' % {"value" : value} )
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on RecargoPctType' % {"value" : value} )
            if value > 999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RecargoPctType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on RecargoPctType' % {"value" : value} )
    def validate_ImpAdicDTEType(self, value):
        # Validate type ImpAdicDTEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['14', '15', '16', '17', '18', '19', '23', '24', '25', '26', '27', '28', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '271', '301', '321', '331', '341', '361', '371', '481']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ImpAdicDTEType' % {"value" : value.encode("utf-8")} )
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.NroLinDet is not None or
            self.CdgItem or
            self.IndExe is not None or
            self.Retenedor is not None or
            self.NmbItem is not None or
            self.DscItem is not None or
            self.QtyRef is not None or
            self.UnmdRef is not None or
            self.PrcRef is not None or
            self.QtyItem is not None or
            self.Subcantidad or
            self.FchElabor is not None or
            self.FchVencim is not None or
            self.UnmdItem is not None or
            self.PrcItem is not None or
            self.OtrMnda is not None or
            self.DescuentoPct is not None or
            self.DescuentoMonto is not None or
            self.SubDscto or
            self.RecargoPct is not None or
            self.RecargoMonto is not None or
            self.SubRecargo or
            self.CodImpAdic or
            self.MontoItem is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DetalleType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetalleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DetalleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DetalleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DetalleType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DetalleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NroLinDet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NroLinDet>%s</SiiDte:NroLinDet>%s' % (self.gds_format_integer(self.NroLinDet, input_name='NroLinDet'), eol_))
        for CdgItem_ in self.CdgItem:
            CdgItem_.export(outfile, level, namespaceprefix_, name_='CdgItem', pretty_print=pretty_print)
        if self.IndExe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndExe>%s</SiiDte:IndExe>%s' % (self.gds_format_integer(self.IndExe, input_name='IndExe'), eol_))
        if self.Retenedor is not None:
            self.Retenedor.export(outfile, level, namespaceprefix_, name_='Retenedor', pretty_print=pretty_print)
        if self.NmbItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NmbItem>%s</SiiDte:NmbItem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NmbItem), input_name='NmbItem')), eol_))
        if self.DscItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DscItem>%s</SiiDte:DscItem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DscItem), input_name='DscItem')), eol_))
        if self.QtyRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:QtyRef>%s</SiiDte:QtyRef>%s' % (self.gds_format_float(self.QtyRef, input_name='QtyRef'), eol_))
        if self.UnmdRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:UnmdRef>%s</SiiDte:UnmdRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnmdRef), input_name='UnmdRef')), eol_))
        if self.PrcRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PrcRef>%s</SiiDte:PrcRef>%s' % (self.gds_format_float(self.PrcRef, input_name='PrcRef'), eol_))
        if self.QtyItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:QtyItem>%s</SiiDte:QtyItem>%s' % (self.gds_format_float(self.QtyItem, input_name='QtyItem'), eol_))
        for Subcantidad_ in self.Subcantidad:
            Subcantidad_.export(outfile, level, namespaceprefix_, name_='Subcantidad', pretty_print=pretty_print)
        if self.FchElabor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchElabor>%s</SiiDte:FchElabor>%s' % (self.gds_format_date(self.FchElabor, input_name='FchElabor'), eol_))
        if self.FchVencim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchVencim>%s</SiiDte:FchVencim>%s' % (self.gds_format_date(self.FchVencim, input_name='FchVencim'), eol_))
        if self.UnmdItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:UnmdItem>%s</SiiDte:UnmdItem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnmdItem), input_name='UnmdItem')), eol_))
        if self.PrcItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PrcItem>%s</SiiDte:PrcItem>%s' % (self.gds_format_float(self.PrcItem, input_name='PrcItem'), eol_))
        if self.OtrMnda is not None:
            self.OtrMnda.export(outfile, level, namespaceprefix_, name_='OtrMnda', pretty_print=pretty_print)
        if self.DescuentoPct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DescuentoPct>%s</SiiDte:DescuentoPct>%s' % (self.gds_format_float(self.DescuentoPct, input_name='DescuentoPct'), eol_))
        if self.DescuentoMonto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DescuentoMonto>%s</SiiDte:DescuentoMonto>%s' % (self.gds_format_integer(self.DescuentoMonto, input_name='DescuentoMonto'), eol_))
        for SubDscto_ in self.SubDscto:
            SubDscto_.export(outfile, level, namespaceprefix_, name_='SubDscto', pretty_print=pretty_print)
        if self.RecargoPct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RecargoPct>%s</SiiDte:RecargoPct>%s' % (self.gds_format_float(self.RecargoPct, input_name='RecargoPct'), eol_))
        if self.RecargoMonto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RecargoMonto>%s</SiiDte:RecargoMonto>%s' % (self.gds_format_integer(self.RecargoMonto, input_name='RecargoMonto'), eol_))
        for SubRecargo_ in self.SubRecargo:
            SubRecargo_.export(outfile, level, namespaceprefix_, name_='SubRecargo', pretty_print=pretty_print)
        for CodImpAdic_ in self.CodImpAdic:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CodImpAdic>%s</SiiDte:CodImpAdic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(CodImpAdic_), input_name='CodImpAdic')), eol_))
        if self.MontoItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MontoItem>%s</SiiDte:MontoItem>%s' % (self.gds_format_integer(self.MontoItem, input_name='MontoItem'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NroLinDet' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NroLinDet')
            self.NroLinDet = ival_
            # validate type NroLinDetType
            self.validate_NroLinDetType(self.NroLinDet)
        elif nodeName_ == 'CdgItem':
            obj_ = CdgItemType.factory()
            obj_.build(child_)
            self.CdgItem.append(obj_)
            obj_.original_tagname_ = 'CdgItem'
        elif nodeName_ == 'IndExe' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndExe')
            self.IndExe = ival_
            # validate type IndExeType
            self.validate_IndExeType(self.IndExe)
        elif nodeName_ == 'Retenedor':
            obj_ = RetenedorType.factory()
            obj_.build(child_)
            self.Retenedor = obj_
            obj_.original_tagname_ = 'Retenedor'
        elif nodeName_ == 'NmbItem':
            NmbItem_ = child_.text
            NmbItem_ = self.gds_validate_string(NmbItem_, node, 'NmbItem')
            self.NmbItem = NmbItem_
            # validate type NmbItemType
            self.validate_NmbItemType(self.NmbItem)
        elif nodeName_ == 'DscItem':
            DscItem_ = child_.text
            DscItem_ = self.gds_validate_string(DscItem_, node, 'DscItem')
            self.DscItem = DscItem_
            # validate type DscItemType
            self.validate_DscItemType(self.DscItem)
        elif nodeName_ == 'QtyRef' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QtyRef')
            self.QtyRef = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.QtyRef)
        elif nodeName_ == 'UnmdRef':
            UnmdRef_ = child_.text
            UnmdRef_ = self.gds_validate_string(UnmdRef_, node, 'UnmdRef')
            self.UnmdRef = UnmdRef_
            # validate type UnmdRefType
            self.validate_UnmdRefType(self.UnmdRef)
        elif nodeName_ == 'PrcRef' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PrcRef')
            self.PrcRef = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.PrcRef)
        elif nodeName_ == 'QtyItem' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QtyItem')
            self.QtyItem = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.QtyItem)
        elif nodeName_ == 'Subcantidad':
            obj_ = SubcantidadType.factory()
            obj_.build(child_)
            self.Subcantidad.append(obj_)
            obj_.original_tagname_ = 'Subcantidad'
        elif nodeName_ == 'FchElabor':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchElabor = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchElabor)
        elif nodeName_ == 'FchVencim':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchVencim = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchVencim)
        elif nodeName_ == 'UnmdItem':
            UnmdItem_ = child_.text
            UnmdItem_ = self.gds_validate_string(UnmdItem_, node, 'UnmdItem')
            self.UnmdItem = UnmdItem_
            # validate type UnmdItemType
            self.validate_UnmdItemType(self.UnmdItem)
        elif nodeName_ == 'PrcItem' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PrcItem')
            self.PrcItem = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.PrcItem)
        elif nodeName_ == 'OtrMnda':
            obj_ = OtrMndaType.factory()
            obj_.build(child_)
            self.OtrMnda = obj_
            obj_.original_tagname_ = 'OtrMnda'
        elif nodeName_ == 'DescuentoPct' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DescuentoPct')
            self.DescuentoPct = fval_
            # validate type PctType
            self.validate_PctType(self.DescuentoPct)
        elif nodeName_ == 'DescuentoMonto' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'DescuentoMonto')
            self.DescuentoMonto = ival_
            # validate type MntImpType
            self.validate_MntImpType(self.DescuentoMonto)
        elif nodeName_ == 'SubDscto':
            obj_ = SubDsctoType.factory()
            obj_.build(child_)
            self.SubDscto.append(obj_)
            obj_.original_tagname_ = 'SubDscto'
        elif nodeName_ == 'RecargoPct' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RecargoPct')
            self.RecargoPct = fval_
            # validate type RecargoPctType
            self.validate_RecargoPctType(self.RecargoPct)
        elif nodeName_ == 'RecargoMonto' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'RecargoMonto')
            self.RecargoMonto = ival_
            # validate type MntImpType
            self.validate_MntImpType(self.RecargoMonto)
        elif nodeName_ == 'SubRecargo':
            obj_ = SubRecargoType.factory()
            obj_.build(child_)
            self.SubRecargo.append(obj_)
            obj_.original_tagname_ = 'SubRecargo'
        elif nodeName_ == 'CodImpAdic':
            CodImpAdic_ = child_.text
            CodImpAdic_ = self.gds_validate_string(CodImpAdic_, node, 'CodImpAdic')
            self.CodImpAdic.append(CodImpAdic_)
            # validate type ImpAdicDTEType
            self.validate_ImpAdicDTEType(self.CodImpAdic[-1])
        elif nodeName_ == 'MontoItem' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MontoItem')
            self.MontoItem = ival_
            # validate type MontoType
            self.validate_MontoType(self.MontoItem)
# end class DetalleType


class CdgItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TpoCodigo=None, VlrCodigo=None):
        self.original_tagname_ = None
        self.TpoCodigo = TpoCodigo
        self.validate_TpoCodigoType(self.TpoCodigo)
        self.VlrCodigo = VlrCodigo
        self.validate_VlrCodigoType(self.VlrCodigo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CdgItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CdgItemType.subclass:
            return CdgItemType.subclass(*args_, **kwargs_)
        else:
            return CdgItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TpoCodigo(self): return self.TpoCodigo
    def set_TpoCodigo(self, TpoCodigo): self.TpoCodigo = TpoCodigo
    def get_VlrCodigo(self): return self.VlrCodigo
    def set_VlrCodigo(self, VlrCodigo): self.VlrCodigo = VlrCodigo
    def validate_TpoCodigoType(self, value):
        # Validate type TpoCodigoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TpoCodigoType' % {"value" : value.encode("utf-8")} )
    def validate_VlrCodigoType(self, value):
        # Validate type VlrCodigoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on VlrCodigoType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TpoCodigo is not None or
            self.VlrCodigo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='CdgItemType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CdgItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CdgItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='CdgItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='CdgItemType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='CdgItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TpoCodigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoCodigo>%s</SiiDte:TpoCodigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoCodigo), input_name='TpoCodigo')), eol_))
        if self.VlrCodigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:VlrCodigo>%s</SiiDte:VlrCodigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VlrCodigo), input_name='VlrCodigo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TpoCodigo':
            TpoCodigo_ = child_.text
            TpoCodigo_ = self.gds_validate_string(TpoCodigo_, node, 'TpoCodigo')
            self.TpoCodigo = TpoCodigo_
            # validate type TpoCodigoType
            self.validate_TpoCodigoType(self.TpoCodigo)
        elif nodeName_ == 'VlrCodigo':
            VlrCodigo_ = child_.text
            VlrCodigo_ = self.gds_validate_string(VlrCodigo_, node, 'VlrCodigo')
            self.VlrCodigo = VlrCodigo_
            # validate type VlrCodigoType
            self.validate_VlrCodigoType(self.VlrCodigo)
# end class CdgItemType


class RetenedorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IndAgente=None, MntBaseFaena=None, MntMargComer=None, PrcConsFinal=None):
        self.original_tagname_ = None
        self.IndAgente = IndAgente
        self.validate_IndAgenteType(self.IndAgente)
        self.MntBaseFaena = MntBaseFaena
        self.validate_MontoType(self.MntBaseFaena)
        self.MntMargComer = MntMargComer
        self.validate_MontoType(self.MntMargComer)
        self.PrcConsFinal = PrcConsFinal
        self.validate_MontoType(self.PrcConsFinal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetenedorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetenedorType.subclass:
            return RetenedorType.subclass(*args_, **kwargs_)
        else:
            return RetenedorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndAgente(self): return self.IndAgente
    def set_IndAgente(self, IndAgente): self.IndAgente = IndAgente
    def get_MntBaseFaena(self): return self.MntBaseFaena
    def set_MntBaseFaena(self, MntBaseFaena): self.MntBaseFaena = MntBaseFaena
    def get_MntMargComer(self): return self.MntMargComer
    def set_MntMargComer(self, MntMargComer): self.MntMargComer = MntMargComer
    def get_PrcConsFinal(self): return self.PrcConsFinal
    def set_PrcConsFinal(self, PrcConsFinal): self.PrcConsFinal = PrcConsFinal
    def validate_IndAgenteType(self, value):
        # Validate type IndAgenteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndAgenteType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IndAgenteType' % {"value" : value.encode("utf-8")} )
    def validate_MontoType(self, value):
        # Validate type MontoType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MontoType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.IndAgente is not None or
            self.MntBaseFaena is not None or
            self.MntMargComer is not None or
            self.PrcConsFinal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='RetenedorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetenedorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetenedorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='RetenedorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='RetenedorType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='RetenedorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IndAgente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndAgente>%s</SiiDte:IndAgente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IndAgente), input_name='IndAgente')), eol_))
        if self.MntBaseFaena is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntBaseFaena>%s</SiiDte:MntBaseFaena>%s' % (self.gds_format_integer(self.MntBaseFaena, input_name='MntBaseFaena'), eol_))
        if self.MntMargComer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MntMargComer>%s</SiiDte:MntMargComer>%s' % (self.gds_format_integer(self.MntMargComer, input_name='MntMargComer'), eol_))
        if self.PrcConsFinal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PrcConsFinal>%s</SiiDte:PrcConsFinal>%s' % (self.gds_format_integer(self.PrcConsFinal, input_name='PrcConsFinal'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndAgente':
            IndAgente_ = child_.text
            IndAgente_ = self.gds_validate_string(IndAgente_, node, 'IndAgente')
            self.IndAgente = IndAgente_
            # validate type IndAgenteType
            self.validate_IndAgenteType(self.IndAgente)
        elif nodeName_ == 'MntBaseFaena' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntBaseFaena')
            self.MntBaseFaena = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntBaseFaena)
        elif nodeName_ == 'MntMargComer' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MntMargComer')
            self.MntMargComer = ival_
            # validate type MontoType
            self.validate_MontoType(self.MntMargComer)
        elif nodeName_ == 'PrcConsFinal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PrcConsFinal')
            self.PrcConsFinal = ival_
            # validate type MontoType
            self.validate_MontoType(self.PrcConsFinal)
# end class RetenedorType


class SubcantidadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SubQty=None, SubCod=None):
        self.original_tagname_ = None
        self.SubQty = SubQty
        self.validate_Dec12_6Type(self.SubQty)
        self.SubCod = SubCod
        self.validate_SubCodType(self.SubCod)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubcantidadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubcantidadType.subclass:
            return SubcantidadType.subclass(*args_, **kwargs_)
        else:
            return SubcantidadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubQty(self): return self.SubQty
    def set_SubQty(self, SubQty): self.SubQty = SubQty
    def get_SubCod(self): return self.SubCod
    def set_SubCod(self, SubCod): self.SubCod = SubCod
    def validate_Dec12_6Type(self, value):
        # Validate type Dec12_6Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec12_6Type' % {"value" : value} )
            if value > 999999999999.999999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
    def validate_SubCodType(self, value):
        # Validate type SubCodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SubCodType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SubQty is not None or
            self.SubCod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubcantidadType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubcantidadType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubcantidadType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SubcantidadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SubcantidadType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubcantidadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubQty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubQty>%s</SiiDte:SubQty>%s' % (self.gds_format_float(self.SubQty, input_name='SubQty'), eol_))
        if self.SubCod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubCod>%s</SiiDte:SubCod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubCod), input_name='SubCod')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubQty' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SubQty')
            self.SubQty = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.SubQty)
        elif nodeName_ == 'SubCod':
            SubCod_ = child_.text
            SubCod_ = self.gds_validate_string(SubCod_, node, 'SubCod')
            self.SubCod = SubCod_
            # validate type SubCodType
            self.validate_SubCodType(self.SubCod)
# end class SubcantidadType


class OtrMndaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PrcOtrMon=None, Moneda=None, FctConv=None, DctoOtrMnda=None, RecargoOtrMnda=None, MontoItemOtrMnda=None):
        self.original_tagname_ = None
        self.PrcOtrMon = PrcOtrMon
        self.validate_Dec12_6Type(self.PrcOtrMon)
        self.Moneda = Moneda
        self.validate_MonedaType(self.Moneda)
        self.FctConv = FctConv
        self.validate_Dec6_4Type(self.FctConv)
        self.DctoOtrMnda = DctoOtrMnda
        self.validate_Dec14_4Type(self.DctoOtrMnda)
        self.RecargoOtrMnda = RecargoOtrMnda
        self.validate_Dec14_4Type(self.RecargoOtrMnda)
        self.MontoItemOtrMnda = MontoItemOtrMnda
        self.validate_Dec14_4Type(self.MontoItemOtrMnda)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtrMndaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtrMndaType.subclass:
            return OtrMndaType.subclass(*args_, **kwargs_)
        else:
            return OtrMndaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrcOtrMon(self): return self.PrcOtrMon
    def set_PrcOtrMon(self, PrcOtrMon): self.PrcOtrMon = PrcOtrMon
    def get_Moneda(self): return self.Moneda
    def set_Moneda(self, Moneda): self.Moneda = Moneda
    def get_FctConv(self): return self.FctConv
    def set_FctConv(self, FctConv): self.FctConv = FctConv
    def get_DctoOtrMnda(self): return self.DctoOtrMnda
    def set_DctoOtrMnda(self, DctoOtrMnda): self.DctoOtrMnda = DctoOtrMnda
    def get_RecargoOtrMnda(self): return self.RecargoOtrMnda
    def set_RecargoOtrMnda(self, RecargoOtrMnda): self.RecargoOtrMnda = RecargoOtrMnda
    def get_MontoItemOtrMnda(self): return self.MontoItemOtrMnda
    def set_MontoItemOtrMnda(self, MontoItemOtrMnda): self.MontoItemOtrMnda = MontoItemOtrMnda
    def validate_Dec12_6Type(self, value):
        # Validate type Dec12_6Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec12_6Type' % {"value" : value} )
            if value > 999999999999.999999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec12_6Type' % {"value" : value} )
    def validate_MonedaType(self, value):
        # Validate type MonedaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on MonedaType' % {"value" : value.encode("utf-8")} )
    def validate_Dec6_4Type(self, value):
        # Validate type Dec6_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec6_4Type' % {"value" : value} )
            if value > 999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec6_4Type' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec6_4Type' % {"value" : value} )
    def validate_Dec14_4Type(self, value):
        # Validate type Dec14_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec14_4Type' % {"value" : value} )
            if value > 99999999999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PrcOtrMon is not None or
            self.Moneda is not None or
            self.FctConv is not None or
            self.DctoOtrMnda is not None or
            self.RecargoOtrMnda is not None or
            self.MontoItemOtrMnda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='OtrMndaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtrMndaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtrMndaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='OtrMndaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='OtrMndaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='OtrMndaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrcOtrMon is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:PrcOtrMon>%s</SiiDte:PrcOtrMon>%s' % (self.gds_format_float(self.PrcOtrMon, input_name='PrcOtrMon'), eol_))
        if self.Moneda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Moneda>%s</SiiDte:Moneda>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Moneda), input_name='Moneda')), eol_))
        if self.FctConv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FctConv>%s</SiiDte:FctConv>%s' % (self.gds_format_float(self.FctConv, input_name='FctConv'), eol_))
        if self.DctoOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DctoOtrMnda>%s</SiiDte:DctoOtrMnda>%s' % (self.gds_format_float(self.DctoOtrMnda, input_name='DctoOtrMnda'), eol_))
        if self.RecargoOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RecargoOtrMnda>%s</SiiDte:RecargoOtrMnda>%s' % (self.gds_format_float(self.RecargoOtrMnda, input_name='RecargoOtrMnda'), eol_))
        if self.MontoItemOtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:MontoItemOtrMnda>%s</SiiDte:MontoItemOtrMnda>%s' % (self.gds_format_float(self.MontoItemOtrMnda, input_name='MontoItemOtrMnda'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrcOtrMon' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PrcOtrMon')
            self.PrcOtrMon = fval_
            # validate type Dec12_6Type
            self.validate_Dec12_6Type(self.PrcOtrMon)
        elif nodeName_ == 'Moneda':
            Moneda_ = child_.text
            Moneda_ = self.gds_validate_string(Moneda_, node, 'Moneda')
            self.Moneda = Moneda_
            # validate type MonedaType
            self.validate_MonedaType(self.Moneda)
        elif nodeName_ == 'FctConv' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FctConv')
            self.FctConv = fval_
            # validate type Dec6_4Type
            self.validate_Dec6_4Type(self.FctConv)
        elif nodeName_ == 'DctoOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DctoOtrMnda')
            self.DctoOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.DctoOtrMnda)
        elif nodeName_ == 'RecargoOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RecargoOtrMnda')
            self.RecargoOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.RecargoOtrMnda)
        elif nodeName_ == 'MontoItemOtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MontoItemOtrMnda')
            self.MontoItemOtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.MontoItemOtrMnda)
# end class OtrMndaType


class SubDsctoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TipoDscto=None, ValorDscto=None):
        self.original_tagname_ = None
        self.TipoDscto = TipoDscto
        self.validate_DineroPorcentajeType(self.TipoDscto)
        self.ValorDscto = ValorDscto
        self.validate_Dec16_2Type(self.ValorDscto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubDsctoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubDsctoType.subclass:
            return SubDsctoType.subclass(*args_, **kwargs_)
        else:
            return SubDsctoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoDscto(self): return self.TipoDscto
    def set_TipoDscto(self, TipoDscto): self.TipoDscto = TipoDscto
    def get_ValorDscto(self): return self.ValorDscto
    def set_ValorDscto(self, ValorDscto): self.ValorDscto = ValorDscto
    def validate_DineroPorcentajeType(self, value):
        # Validate type DineroPorcentajeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['%', '$']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
    def validate_Dec16_2Type(self, value):
        # Validate type Dec16_2Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec16_2Type' % {"value" : value} )
            if value > 9999999999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoDscto is not None or
            self.ValorDscto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubDsctoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubDsctoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubDsctoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SubDsctoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SubDsctoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubDsctoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoDscto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoDscto>%s</SiiDte:TipoDscto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoDscto), input_name='TipoDscto')), eol_))
        if self.ValorDscto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValorDscto>%s</SiiDte:ValorDscto>%s' % (self.gds_format_float(self.ValorDscto, input_name='ValorDscto'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoDscto':
            TipoDscto_ = child_.text
            TipoDscto_ = self.gds_validate_string(TipoDscto_, node, 'TipoDscto')
            self.TipoDscto = TipoDscto_
            # validate type DineroPorcentajeType
            self.validate_DineroPorcentajeType(self.TipoDscto)
        elif nodeName_ == 'ValorDscto' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDscto')
            self.ValorDscto = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.ValorDscto)
# end class SubDsctoType


class SubRecargoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TipoRecargo=None, ValorRecargo=None):
        self.original_tagname_ = None
        self.TipoRecargo = TipoRecargo
        self.validate_DineroPorcentajeType(self.TipoRecargo)
        self.ValorRecargo = ValorRecargo
        self.validate_Dec16_2Type(self.ValorRecargo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubRecargoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubRecargoType.subclass:
            return SubRecargoType.subclass(*args_, **kwargs_)
        else:
            return SubRecargoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoRecargo(self): return self.TipoRecargo
    def set_TipoRecargo(self, TipoRecargo): self.TipoRecargo = TipoRecargo
    def get_ValorRecargo(self): return self.ValorRecargo
    def set_ValorRecargo(self, ValorRecargo): self.ValorRecargo = ValorRecargo
    def validate_DineroPorcentajeType(self, value):
        # Validate type DineroPorcentajeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['%', '$']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
    def validate_Dec16_2Type(self, value):
        # Validate type Dec16_2Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec16_2Type' % {"value" : value} )
            if value > 9999999999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoRecargo is not None or
            self.ValorRecargo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubRecargoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubRecargoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubRecargoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SubRecargoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SubRecargoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubRecargoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoRecargo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TipoRecargo>%s</SiiDte:TipoRecargo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TipoRecargo), input_name='TipoRecargo')), eol_))
        if self.ValorRecargo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValorRecargo>%s</SiiDte:ValorRecargo>%s' % (self.gds_format_float(self.ValorRecargo, input_name='ValorRecargo'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoRecargo':
            TipoRecargo_ = child_.text
            TipoRecargo_ = self.gds_validate_string(TipoRecargo_, node, 'TipoRecargo')
            self.TipoRecargo = TipoRecargo_
            # validate type DineroPorcentajeType
            self.validate_DineroPorcentajeType(self.TipoRecargo)
        elif nodeName_ == 'ValorRecargo' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorRecargo')
            self.ValorRecargo = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.ValorRecargo)
# end class SubRecargoType


class SubTotInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NroSTI=None, GlosaSTI=None, OrdenSTI=None, SubTotNetoSTI=None, SubTotIVASTI=None, SubTotAdicSTI=None, SubTotExeSTI=None, ValSubtotSTI=None, LineasDeta=None):
        self.original_tagname_ = None
        self.NroSTI = NroSTI
        self.validate_NroSTIType(self.NroSTI)
        self.GlosaSTI = GlosaSTI
        self.validate_GlosaSTIType(self.GlosaSTI)
        self.OrdenSTI = OrdenSTI
        self.validate_OrdenSTIType(self.OrdenSTI)
        self.SubTotNetoSTI = SubTotNetoSTI
        self.validate_Dec16_2Type(self.SubTotNetoSTI)
        self.SubTotIVASTI = SubTotIVASTI
        self.validate_Dec16_2Type(self.SubTotIVASTI)
        self.SubTotAdicSTI = SubTotAdicSTI
        self.validate_Dec16_2Type(self.SubTotAdicSTI)
        self.SubTotExeSTI = SubTotExeSTI
        self.validate_Dec16_2Type(self.SubTotExeSTI)
        self.ValSubtotSTI = ValSubtotSTI
        self.validate_Dec16_2Type(self.ValSubtotSTI)
        if LineasDeta is None:
            self.LineasDeta = []
        else:
            self.LineasDeta = LineasDeta
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubTotInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubTotInfoType.subclass:
            return SubTotInfoType.subclass(*args_, **kwargs_)
        else:
            return SubTotInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NroSTI(self): return self.NroSTI
    def set_NroSTI(self, NroSTI): self.NroSTI = NroSTI
    def get_GlosaSTI(self): return self.GlosaSTI
    def set_GlosaSTI(self, GlosaSTI): self.GlosaSTI = GlosaSTI
    def get_OrdenSTI(self): return self.OrdenSTI
    def set_OrdenSTI(self, OrdenSTI): self.OrdenSTI = OrdenSTI
    def get_SubTotNetoSTI(self): return self.SubTotNetoSTI
    def set_SubTotNetoSTI(self, SubTotNetoSTI): self.SubTotNetoSTI = SubTotNetoSTI
    def get_SubTotIVASTI(self): return self.SubTotIVASTI
    def set_SubTotIVASTI(self, SubTotIVASTI): self.SubTotIVASTI = SubTotIVASTI
    def get_SubTotAdicSTI(self): return self.SubTotAdicSTI
    def set_SubTotAdicSTI(self, SubTotAdicSTI): self.SubTotAdicSTI = SubTotAdicSTI
    def get_SubTotExeSTI(self): return self.SubTotExeSTI
    def set_SubTotExeSTI(self, SubTotExeSTI): self.SubTotExeSTI = SubTotExeSTI
    def get_ValSubtotSTI(self): return self.ValSubtotSTI
    def set_ValSubtotSTI(self, ValSubtotSTI): self.ValSubtotSTI = ValSubtotSTI
    def get_LineasDeta(self): return self.LineasDeta
    def set_LineasDeta(self, LineasDeta): self.LineasDeta = LineasDeta
    def add_LineasDeta(self, value): self.LineasDeta.append(value)
    def insert_LineasDeta_at(self, index, value): self.LineasDeta.insert(index, value)
    def replace_LineasDeta_at(self, index, value): self.LineasDeta[index] = value
    def validate_NroSTIType(self, value):
        # Validate type NroSTIType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NroSTIType' % {"value" : value} )
    def validate_GlosaSTIType(self, value):
        # Validate type GlosaSTIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlosaSTIType' % {"value" : value.encode("utf-8")} )
    def validate_OrdenSTIType(self, value):
        # Validate type OrdenSTIType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on OrdenSTIType' % {"value" : value} )
    def validate_Dec16_2Type(self, value):
        # Validate type Dec16_2Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec16_2Type' % {"value" : value} )
            if value > 9999999999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
    def validate_LineasDetaType(self, value):
        # Validate type LineasDetaType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.NroSTI is not None or
            self.GlosaSTI is not None or
            self.OrdenSTI is not None or
            self.SubTotNetoSTI is not None or
            self.SubTotIVASTI is not None or
            self.SubTotAdicSTI is not None or
            self.SubTotExeSTI is not None or
            self.ValSubtotSTI is not None or
            self.LineasDeta
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubTotInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubTotInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubTotInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SubTotInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SubTotInfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SubTotInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NroSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NroSTI>%s</SiiDte:NroSTI>%s' % (self.gds_format_integer(self.NroSTI, input_name='NroSTI'), eol_))
        if self.GlosaSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GlosaSTI>%s</SiiDte:GlosaSTI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlosaSTI), input_name='GlosaSTI')), eol_))
        if self.OrdenSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:OrdenSTI>%s</SiiDte:OrdenSTI>%s' % (self.gds_format_integer(self.OrdenSTI, input_name='OrdenSTI'), eol_))
        if self.SubTotNetoSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubTotNetoSTI>%s</SiiDte:SubTotNetoSTI>%s' % (self.gds_format_float(self.SubTotNetoSTI, input_name='SubTotNetoSTI'), eol_))
        if self.SubTotIVASTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubTotIVASTI>%s</SiiDte:SubTotIVASTI>%s' % (self.gds_format_float(self.SubTotIVASTI, input_name='SubTotIVASTI'), eol_))
        if self.SubTotAdicSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubTotAdicSTI>%s</SiiDte:SubTotAdicSTI>%s' % (self.gds_format_float(self.SubTotAdicSTI, input_name='SubTotAdicSTI'), eol_))
        if self.SubTotExeSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:SubTotExeSTI>%s</SiiDte:SubTotExeSTI>%s' % (self.gds_format_float(self.SubTotExeSTI, input_name='SubTotExeSTI'), eol_))
        if self.ValSubtotSTI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValSubtotSTI>%s</SiiDte:ValSubtotSTI>%s' % (self.gds_format_float(self.ValSubtotSTI, input_name='ValSubtotSTI'), eol_))
        for LineasDeta_ in self.LineasDeta:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:LineasDeta>%s</SiiDte:LineasDeta>%s' % (self.gds_format_integer(LineasDeta_, input_name='LineasDeta'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NroSTI' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NroSTI')
            self.NroSTI = ival_
            # validate type NroSTIType
            self.validate_NroSTIType(self.NroSTI)
        elif nodeName_ == 'GlosaSTI':
            GlosaSTI_ = child_.text
            GlosaSTI_ = self.gds_validate_string(GlosaSTI_, node, 'GlosaSTI')
            self.GlosaSTI = GlosaSTI_
            # validate type GlosaSTIType
            self.validate_GlosaSTIType(self.GlosaSTI)
        elif nodeName_ == 'OrdenSTI' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'OrdenSTI')
            self.OrdenSTI = ival_
            # validate type OrdenSTIType
            self.validate_OrdenSTIType(self.OrdenSTI)
        elif nodeName_ == 'SubTotNetoSTI' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SubTotNetoSTI')
            self.SubTotNetoSTI = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.SubTotNetoSTI)
        elif nodeName_ == 'SubTotIVASTI' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SubTotIVASTI')
            self.SubTotIVASTI = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.SubTotIVASTI)
        elif nodeName_ == 'SubTotAdicSTI' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SubTotAdicSTI')
            self.SubTotAdicSTI = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.SubTotAdicSTI)
        elif nodeName_ == 'SubTotExeSTI' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SubTotExeSTI')
            self.SubTotExeSTI = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.SubTotExeSTI)
        elif nodeName_ == 'ValSubtotSTI' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValSubtotSTI')
            self.ValSubtotSTI = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.ValSubtotSTI)
        elif nodeName_ == 'LineasDeta' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'LineasDeta')
            self.LineasDeta.append(ival_)
            # validate type LineasDetaType
            self.validate_LineasDetaType(self.LineasDeta[-1])
# end class SubTotInfoType


class DscRcgGlobalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NroLinDR=None, TpoMov=None, GlosaDR=None, TpoValor=None, ValorDR=None, ValorDROtrMnda=None, IndExeDR=None):
        self.original_tagname_ = None
        self.NroLinDR = NroLinDR
        self.TpoMov = TpoMov
        self.validate_TpoMovType(self.TpoMov)
        self.GlosaDR = GlosaDR
        self.validate_GlosaDRType(self.GlosaDR)
        self.TpoValor = TpoValor
        self.validate_DineroPorcentajeType(self.TpoValor)
        self.ValorDR = ValorDR
        self.validate_Dec16_2Type(self.ValorDR)
        self.ValorDROtrMnda = ValorDROtrMnda
        self.validate_Dec14_4Type(self.ValorDROtrMnda)
        self.IndExeDR = IndExeDR
        self.validate_IndExeDRType(self.IndExeDR)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DscRcgGlobalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DscRcgGlobalType.subclass:
            return DscRcgGlobalType.subclass(*args_, **kwargs_)
        else:
            return DscRcgGlobalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NroLinDR(self): return self.NroLinDR
    def set_NroLinDR(self, NroLinDR): self.NroLinDR = NroLinDR
    def get_TpoMov(self): return self.TpoMov
    def set_TpoMov(self, TpoMov): self.TpoMov = TpoMov
    def get_GlosaDR(self): return self.GlosaDR
    def set_GlosaDR(self, GlosaDR): self.GlosaDR = GlosaDR
    def get_TpoValor(self): return self.TpoValor
    def set_TpoValor(self, TpoValor): self.TpoValor = TpoValor
    def get_ValorDR(self): return self.ValorDR
    def set_ValorDR(self, ValorDR): self.ValorDR = ValorDR
    def get_ValorDROtrMnda(self): return self.ValorDROtrMnda
    def set_ValorDROtrMnda(self, ValorDROtrMnda): self.ValorDROtrMnda = ValorDROtrMnda
    def get_IndExeDR(self): return self.IndExeDR
    def set_IndExeDR(self, IndExeDR): self.IndExeDR = IndExeDR
    def validate_TpoMovType(self, value):
        # Validate type TpoMovType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D', 'R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TpoMovType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TpoMovType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TpoMovType' % {"value" : value.encode("utf-8")} )
    def validate_GlosaDRType(self, value):
        # Validate type GlosaDRType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlosaDRType' % {"value" : value.encode("utf-8")} )
    def validate_DineroPorcentajeType(self, value):
        # Validate type DineroPorcentajeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['%', '$']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on DineroPorcentajeType' % {"value" : value.encode("utf-8")} )
    def validate_Dec16_2Type(self, value):
        # Validate type Dec16_2Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec16_2Type' % {"value" : value} )
            if value > 9999999999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec16_2Type' % {"value" : value} )
    def validate_Dec14_4Type(self, value):
        # Validate type Dec14_4Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0001:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Dec14_4Type' % {"value" : value} )
            if value > 99999999999999.9999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Dec14_4Type' % {"value" : value} )
    def validate_IndExeDRType(self, value):
        # Validate type IndExeDRType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndExeDRType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NroLinDR is not None or
            self.TpoMov is not None or
            self.GlosaDR is not None or
            self.TpoValor is not None or
            self.ValorDR is not None or
            self.ValorDROtrMnda is not None or
            self.IndExeDR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DscRcgGlobalType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DscRcgGlobalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DscRcgGlobalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DscRcgGlobalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DscRcgGlobalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DscRcgGlobalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NroLinDR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NroLinDR>%s</SiiDte:NroLinDR>%s' % (self.gds_format_integer(self.NroLinDR, input_name='NroLinDR'), eol_))
        if self.TpoMov is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoMov>%s</SiiDte:TpoMov>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoMov), input_name='TpoMov')), eol_))
        if self.GlosaDR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:GlosaDR>%s</SiiDte:GlosaDR>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlosaDR), input_name='GlosaDR')), eol_))
        if self.TpoValor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoValor>%s</SiiDte:TpoValor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoValor), input_name='TpoValor')), eol_))
        if self.ValorDR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValorDR>%s</SiiDte:ValorDR>%s' % (self.gds_format_float(self.ValorDR, input_name='ValorDR'), eol_))
        if self.ValorDROtrMnda is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:ValorDROtrMnda>%s</SiiDte:ValorDROtrMnda>%s' % (self.gds_format_float(self.ValorDROtrMnda, input_name='ValorDROtrMnda'), eol_))
        if self.IndExeDR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndExeDR>%s</SiiDte:IndExeDR>%s' % (self.gds_format_integer(self.IndExeDR, input_name='IndExeDR'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NroLinDR' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NroLinDR')
            self.NroLinDR = ival_
        elif nodeName_ == 'TpoMov':
            TpoMov_ = child_.text
            TpoMov_ = self.gds_validate_string(TpoMov_, node, 'TpoMov')
            self.TpoMov = TpoMov_
            # validate type TpoMovType
            self.validate_TpoMovType(self.TpoMov)
        elif nodeName_ == 'GlosaDR':
            GlosaDR_ = child_.text
            GlosaDR_ = self.gds_validate_string(GlosaDR_, node, 'GlosaDR')
            self.GlosaDR = GlosaDR_
            # validate type GlosaDRType
            self.validate_GlosaDRType(self.GlosaDR)
        elif nodeName_ == 'TpoValor':
            TpoValor_ = child_.text
            TpoValor_ = self.gds_validate_string(TpoValor_, node, 'TpoValor')
            self.TpoValor = TpoValor_
            # validate type DineroPorcentajeType
            self.validate_DineroPorcentajeType(self.TpoValor)
        elif nodeName_ == 'ValorDR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDR')
            self.ValorDR = fval_
            # validate type Dec16_2Type
            self.validate_Dec16_2Type(self.ValorDR)
        elif nodeName_ == 'ValorDROtrMnda' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDROtrMnda')
            self.ValorDROtrMnda = fval_
            # validate type Dec14_4Type
            self.validate_Dec14_4Type(self.ValorDROtrMnda)
        elif nodeName_ == 'IndExeDR' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndExeDR')
            self.IndExeDR = ival_
            # validate type IndExeDRType
            self.validate_IndExeDRType(self.IndExeDR)
# end class DscRcgGlobalType


class ReferenciaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NroLinRef=None, TpoDocRef=None, IndGlobal=None, FolioRef=None, RUTOtr=None, FchRef=None, CodRef=None, RazonRef=None):
        self.original_tagname_ = None
        self.NroLinRef = NroLinRef
        self.validate_NroLinRefType(self.NroLinRef)
        self.TpoDocRef = TpoDocRef
        self.validate_TpoDocRefType(self.TpoDocRef)
        self.IndGlobal = IndGlobal
        self.validate_IndGlobalType(self.IndGlobal)
        self.FolioRef = FolioRef
        self.validate_FolioRType(self.FolioRef)
        self.RUTOtr = RUTOtr
        self.validate_RUTType(self.RUTOtr)
        if isinstance(FchRef, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FchRef, '%Y-%m-%d').date()
        else:
            initvalue_ = FchRef
        self.FchRef = initvalue_
        self.CodRef = CodRef
        self.validate_CodRefType(self.CodRef)
        self.RazonRef = RazonRef
        self.validate_RazonRefType(self.RazonRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenciaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenciaType.subclass:
            return ReferenciaType.subclass(*args_, **kwargs_)
        else:
            return ReferenciaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NroLinRef(self): return self.NroLinRef
    def set_NroLinRef(self, NroLinRef): self.NroLinRef = NroLinRef
    def get_TpoDocRef(self): return self.TpoDocRef
    def set_TpoDocRef(self, TpoDocRef): self.TpoDocRef = TpoDocRef
    def get_IndGlobal(self): return self.IndGlobal
    def set_IndGlobal(self, IndGlobal): self.IndGlobal = IndGlobal
    def get_FolioRef(self): return self.FolioRef
    def set_FolioRef(self, FolioRef): self.FolioRef = FolioRef
    def get_RUTOtr(self): return self.RUTOtr
    def set_RUTOtr(self, RUTOtr): self.RUTOtr = RUTOtr
    def get_FchRef(self): return self.FchRef
    def set_FchRef(self, FchRef): self.FchRef = FchRef
    def get_CodRef(self): return self.CodRef
    def set_CodRef(self, CodRef): self.CodRef = CodRef
    def get_RazonRef(self): return self.RazonRef
    def set_RazonRef(self, RazonRef): self.RazonRef = RazonRef
    def validate_NroLinRefType(self, value):
        # Validate type NroLinRefType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NroLinRefType' % {"value" : value} )
    def validate_TpoDocRefType(self, value):
        # Validate type TpoDocRefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TpoDocRefType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TpoDocRefType' % {"value" : value.encode("utf-8")} )
    def validate_IndGlobalType(self, value):
        # Validate type IndGlobalType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IndGlobalType' % {"value" : value.encode("utf-8")} )
            if len(str(value)) >= 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on IndGlobalType' % {"value" : value} )
    def validate_FolioRType(self, value):
        # Validate type FolioRType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FolioRType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FolioRType' % {"value" : value.encode("utf-8")} )
    def validate_RUTType(self, value):
        # Validate type RUTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RUTType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_RUTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RUTType_patterns_, ))
    validate_RUTType_patterns_ = [[u'^[0-9]+-([0-9]|K)$']]
    def validate_FechaType(self, value):
        # Validate type FechaType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_:
            if value < self.gds_parse_date('2000-01-01'):
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FechaType' % {"value" : value} )
            if value > self.gds_parse_date('2050-12-31'):
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on FechaType' % {"value" : value} )
    def validate_CodRefType(self, value):
        # Validate type CodRefType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodRefType' % {"value" : value.encode("utf-8")} )
    def validate_RazonRefType(self, value):
        # Validate type RazonRefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 90:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RazonRefType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NroLinRef is not None or
            self.TpoDocRef is not None or
            self.IndGlobal is not None or
            self.FolioRef is not None or
            self.RUTOtr is not None or
            self.FchRef is not None or
            self.CodRef is not None or
            self.RazonRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReferenciaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenciaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenciaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ReferenciaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ReferenciaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReferenciaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NroLinRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:NroLinRef>%s</SiiDte:NroLinRef>%s' % (self.gds_format_integer(self.NroLinRef, input_name='NroLinRef'), eol_))
        if self.TpoDocRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:TpoDocRef>%s</SiiDte:TpoDocRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TpoDocRef), input_name='TpoDocRef')), eol_))
        if self.IndGlobal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:IndGlobal>%s</SiiDte:IndGlobal>%s' % (self.gds_format_integer(self.IndGlobal, input_name='IndGlobal'), eol_))
        if self.FolioRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FolioRef>%s</SiiDte:FolioRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FolioRef), input_name='FolioRef')), eol_))
        if self.RUTOtr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RUTOtr>%s</SiiDte:RUTOtr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RUTOtr), input_name='RUTOtr')), eol_))
        if self.FchRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:FchRef>%s</SiiDte:FchRef>%s' % (self.gds_format_date(self.FchRef, input_name='FchRef'), eol_))
        if self.CodRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:CodRef>%s</SiiDte:CodRef>%s' % (self.gds_format_integer(self.CodRef, input_name='CodRef'), eol_))
        if self.RazonRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:RazonRef>%s</SiiDte:RazonRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RazonRef), input_name='RazonRef')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NroLinRef' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NroLinRef')
            self.NroLinRef = ival_
            # validate type NroLinRefType
            self.validate_NroLinRefType(self.NroLinRef)
        elif nodeName_ == 'TpoDocRef':
            TpoDocRef_ = child_.text
            TpoDocRef_ = self.gds_validate_string(TpoDocRef_, node, 'TpoDocRef')
            self.TpoDocRef = TpoDocRef_
            # validate type TpoDocRefType
            self.validate_TpoDocRefType(self.TpoDocRef)
        elif nodeName_ == 'IndGlobal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'IndGlobal')
            self.IndGlobal = ival_
            # validate type IndGlobalType
            self.validate_IndGlobalType(self.IndGlobal)
        elif nodeName_ == 'FolioRef':
            FolioRef_ = child_.text
            FolioRef_ = self.gds_validate_string(FolioRef_, node, 'FolioRef')
            self.FolioRef = FolioRef_
            # validate type FolioRType
            self.validate_FolioRType(self.FolioRef)
        elif nodeName_ == 'RUTOtr':
            RUTOtr_ = child_.text
            RUTOtr_ = self.gds_validate_string(RUTOtr_, node, 'RUTOtr')
            self.RUTOtr = RUTOtr_
            # validate type RUTType
            self.validate_RUTType(self.RUTOtr)
        elif nodeName_ == 'FchRef':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FchRef = dval_
            # validate type FechaType
            self.validate_FechaType(self.FchRef)
        elif nodeName_ == 'CodRef' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CodRef')
            self.CodRef = ival_
            # validate type CodRefType
            self.validate_CodRefType(self.CodRef)
        elif nodeName_ == 'RazonRef':
            RazonRef_ = child_.text
            RazonRef_ = self.gds_validate_string(RazonRef_, node, 'RazonRef')
            self.RazonRef = RazonRef_
            # validate type RazonRefType
            self.validate_RazonRefType(self.RazonRef)
# end class ReferenciaType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self): return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod): self.SignatureMethod = SignatureMethod
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SignedInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SignedInfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_, name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespaceprefix_, name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(outfile, level, namespaceprefix_, name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/TR/2001/REC-xml-c14n-20010315'):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='CanonicalizationMethodType'):
        if self.Algorithm != "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='SignatureMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, URI=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.URI = _cast(None, URI)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_DigestMethod(self): return self.DigestMethod
    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod
    def get_DigestValue(self): return self.DigestValue
    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='ReferenceType'):
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespaceprefix_, name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespaceprefix_, name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:DigestValue>%s</SiiDte:DigestValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DigestValue), input_name='DigestValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            DigestValue_ = child_.text
            DigestValue_ = self.gds_validate_string(DigestValue_, node, 'DigestValue')
            self.DigestValue = DigestValue_
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def hasContent_(self):
        if (
            self.Transform is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='TransformsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transform is not None:
            self.Transform.export(outfile, level, namespaceprefix_, name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform = obj_
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='TransformType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='TransformType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='TransformType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TransformType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/2000/09/xmldsig#sha1'):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DigestMethodType'):
        if self.Algorithm != "http://www.w3.org/2000/09/xmldsig#sha1" and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KeyValue=None, X509Data=None):
        self.original_tagname_ = None
        self.KeyValue = KeyValue
        self.X509Data = X509Data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyValue(self): return self.KeyValue
    def set_KeyValue(self, KeyValue): self.KeyValue = KeyValue
    def get_X509Data(self): return self.X509Data
    def set_X509Data(self, X509Data): self.X509Data = X509Data
    def hasContent_(self):
        if (
            self.KeyValue is not None or
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='KeyInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='KeyInfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KeyValue is not None:
            self.KeyValue.export(outfile, level, namespaceprefix_, name_='KeyValue', pretty_print=pretty_print)
        if self.X509Data is not None:
            self.X509Data.export(outfile, level, namespaceprefix_, name_='X509Data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyValue':
            obj_ = KeyValueType.factory()
            obj_.build(child_)
            self.KeyValue = obj_
            obj_.original_tagname_ = 'KeyValue'
        elif nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class KeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RSAKeyValue=None, DSAKeyValue=None):
        self.original_tagname_ = None
        self.RSAKeyValue = RSAKeyValue
        self.DSAKeyValue = DSAKeyValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueType.subclass:
            return KeyValueType.subclass(*args_, **kwargs_)
        else:
            return KeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RSAKeyValue(self): return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue): self.RSAKeyValue = RSAKeyValue
    def get_DSAKeyValue(self): return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue): self.DSAKeyValue = DSAKeyValue
    def hasContent_(self):
        if (
            self.RSAKeyValue is not None or
            self.DSAKeyValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='KeyValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='KeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='KeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='KeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RSAKeyValue is not None:
            self.RSAKeyValue.export(outfile, level, namespaceprefix_, name_='RSAKeyValue', pretty_print=pretty_print)
        if self.DSAKeyValue is not None:
            self.DSAKeyValue.export(outfile, level, namespaceprefix_, name_='DSAKeyValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RSAKeyValue':
            obj_ = RSAKeyValueType.factory()
            obj_.build(child_)
            self.RSAKeyValue = obj_
            obj_.original_tagname_ = 'RSAKeyValue'
        elif nodeName_ == 'DSAKeyValue':
            obj_ = DSAKeyValueType.factory()
            obj_.build(child_)
            self.DSAKeyValue = obj_
            obj_.original_tagname_ = 'DSAKeyValue'
# end class KeyValueType


class RSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None):
        self.original_tagname_ = None
        self.Modulus = Modulus
        self.Exponent = Exponent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSAKeyValueType.subclass:
            return RSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modulus(self): return self.Modulus
    def set_Modulus(self, Modulus): self.Modulus = Modulus
    def get_Exponent(self): return self.Exponent
    def set_Exponent(self, Exponent): self.Exponent = Exponent
    def hasContent_(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='RSAKeyValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='RSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='RSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='RSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modulus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Modulus>%s</SiiDte:Modulus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Modulus), input_name='Modulus')), eol_))
        if self.Exponent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Exponent>%s</SiiDte:Exponent>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Exponent), input_name='Exponent')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Modulus':
            Modulus_ = child_.text
            Modulus_ = self.gds_validate_string(Modulus_, node, 'Modulus')
            self.Modulus = Modulus_
        elif nodeName_ == 'Exponent':
            Exponent_ = child_.text
            Exponent_ = self.gds_validate_string(Exponent_, node, 'Exponent')
            self.Exponent = Exponent_
# end class RSAKeyValueType


class DSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None):
        self.original_tagname_ = None
        self.P = P
        self.Q = Q
        self.G = G
        self.Y = Y
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSAKeyValueType.subclass:
            return DSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def get_G(self): return self.G
    def set_G(self, G): self.G = G
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def hasContent_(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='DSAKeyValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='DSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='DSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='DSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.P is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:P>%s</SiiDte:P>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.P), input_name='P')), eol_))
        if self.Q is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Q>%s</SiiDte:Q>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Q), input_name='Q')), eol_))
        if self.G is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:G>%s</SiiDte:G>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.G), input_name='G')), eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:Y>%s</SiiDte:Y>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Y), input_name='Y')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P':
            P_ = child_.text
            P_ = self.gds_validate_string(P_, node, 'P')
            self.P = P_
        elif nodeName_ == 'Q':
            Q_ = child_.text
            Q_ = self.gds_validate_string(Q_, node, 'Q')
            self.Q = Q_
        elif nodeName_ == 'G':
            G_ = child_.text
            G_ = self.gds_validate_string(G_, node, 'G')
            self.G = G_
        elif nodeName_ == 'Y':
            Y_ = child_.text
            Y_ = self.gds_validate_string(Y_, node, 'Y')
            self.Y = Y_
# end class DSAKeyValueType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None):
        self.original_tagname_ = None
        self.X509Certificate = X509Certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509Certificate(self): return self.X509Certificate
    def set_X509Certificate(self, X509Certificate): self.X509Certificate = X509Certificate
    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='SiiDte:', name_='X509DataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='SiiDte:', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='SiiDte:', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='SiiDte:', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiiDte:X509Certificate>%s</SiiDte:X509Certificate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


GDSClassesMapping = {
    'Signature': SignatureType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DocumentoCedible'
        rootClass = DocumentoCedible
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:SiiDte="http://www.sii.cl/SiiDte"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DocumentoCedible'
        rootClass = DocumentoCedible
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DocumentoCedible'
        rootClass = DocumentoCedible
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:SiiDte="http://www.sii.cl/SiiDte"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DocumentoCedible'
        rootClass = DocumentoCedible
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from documentoCedible import *\n\n')
        sys.stdout.write('import documentoCedible as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CanonicalizationMethodType",
    "CdgItemType",
    "ComisionesType",
    "DSAKeyValueType",
    "DetalleType",
    "DigestMethodType",
    "DocumentoCedible",
    "DocumentoType",
    "DscRcgGlobalType",
    "EmisorType",
    "EncabezadoType",
    "ExtranjeroType",
    "GuiaExportType",
    "IdDocType",
    "ImpRetOtrMndaType",
    "ImptoRetenType",
    "KeyInfoType",
    "KeyValueType",
    "MntPagosType",
    "OtrMndaType",
    "OtraMonedaType",
    "RSAKeyValueType",
    "ReceptorType",
    "ReferenceType",
    "ReferenciaType",
    "RetenedorType",
    "SignatureMethodType",
    "SignatureType",
    "SignedInfoType",
    "SubDsctoType",
    "SubRecargoType",
    "SubTotInfoType",
    "SubcantidadType",
    "TotalesType",
    "TransformType",
    "TransformsType",
    "X509DataType"
]
