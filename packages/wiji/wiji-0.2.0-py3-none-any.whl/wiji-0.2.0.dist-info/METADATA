Metadata-Version: 2.1
Name: wiji
Version: 0.2.0
Summary: Wiji is an asyncio distributed task processor/queue.
Home-page: https://github.com/komuw/wiji
Author: komuW
Author-email: komuw05@gmail.com
License: MIT
Keywords: wiji,blah
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Build Tools
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Topic :: Security
Classifier: Topic :: System :: Installation/Setup
Classifier: Topic :: System :: Networking
Classifier: Topic :: System :: Systems Administration
Classifier: Topic :: Utilities
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.6
Provides-Extra: dev
Requires-Dist: pypandoc ; extra == 'dev'
Requires-Dist: twine ; extra == 'dev'
Requires-Dist: wheel ; extra == 'dev'
Requires-Dist: Sphinx (==1.8.3) ; extra == 'dev'
Requires-Dist: sphinx-autodoc-typehints (==1.6.0) ; extra == 'dev'
Provides-Extra: test
Requires-Dist: coverage ; extra == 'test'
Requires-Dist: flake8 ; extra == 'test'
Requires-Dist: pylint ; extra == 'test'
Requires-Dist: black ; extra == 'test'
Requires-Dist: bandit ; extra == 'test'
Requires-Dist: mypy ; extra == 'test'
Requires-Dist: codecov ; extra == 'test'
Requires-Dist: redis (==2.10.6) ; extra == 'test'
Requires-Dist: docker (==3.7.1) ; extra == 'test'

wiji
----

|Codacy Badge| |CircleCI| |codecov| |Code style: black|

| ``Wiji`` is an asyncio distributed task processor/queue.
| It's name is derived from the late Kenyan hip hop artiste, Gwiji.

It is a bit like `Celery <https://github.com/celery/celery>`__

``wiji`` has no third-party dependencies and it requires python version
3.7+

| ``wiji`` is work in progress and very early. It's API may change in
  backward incompatible ways.
| https://pypi.python.org/pypi/wiji

| **Contents:**
| `Installation <#installation>`__
| `Usage <#usage>`__
| + `As a library <#1-as-a-library>`__
| + `As cli app <#2-as-a-cli-app>`__
| + `Writing tests <#writing-tests>`__

| `Features <#features>`__
| + `async everywhere <#1-async-everywhere>`__
| + `monitoring-and-observability <#2-monitoring-and-observability>`__
| + `logging <#21-logging>`__
| + `hooks <#22-hooks>`__ + `Rate limiting <#3-rate-limiting>`__
| + `Queuing <#5-queuing>`__

Installation
------------

.. code:: shell

    pip install wiji

Usage
-----

1. As a library
^^^^^^^^^^^^^^^

.. code:: python

    import asyncio
    import wiji

    class AdderTask(wiji.task.Task):
        the_broker = wiji.broker.InMemoryBroker()
        queue_name = "AdderTaskQueue1"

        async def run(self, a, b):
            result = a + b
            print("\nresult: {0}\n".format(result))
            return result

    # queue some tasks
    myAdderTask = AdderTask( )
    myAdderTask.synchronous_delay(a=4, b=37)
    myAdderTask.synchronous_delay(a=67, b=847)

    # run the workers
    worker = wiji.Worker(the_task=myAdderTask)
    asyncio.run(worker.consume_tasks())

2. As a cli app
^^^^^^^^^^^^^^^

``wiji`` also ships with a commandline app called ``wiji-cli``.

| create a ``wiji`` app file(which is just any python file that has a
  class instance of ``wiji.app.App``), eg;
| ``examples/my_app.py``

.. code:: python

    import wiji

    class AdderTask(wiji.task.Task):
        the_broker = wiji.broker.InMemoryBroker()
        queue_name = "AdderTaskQueue1"

        async def run(self, a, b):
            res = a + b
            print()
            print("res:: ", res)
            print()
            return res

    MyAppInstance = wiji.app.App(task_classes=[AdderTask])

| **NB:** the directory where your place that file(in this case;
  ``examples/``) ought to be in your ``PYTHONPATH``
| then run ``wiji-cli`` pointing it to the dotted path of the
  ``wiji.app.App`` instance:

.. code:: bash

    wiji-cli --app examples.my_app.MyAppInstance

Writing tests
^^^^^^^^^^^^^

Lets say you have ``wiji`` tasks in your project and you want to write
integration or unit tests for them and their use.

.. code:: python


    # my_tasks.py

    import wiji
    import MyRedisBroker # a custom broker using redis

    DATABASE = {}

    class AdderTask(wiji.task.Task):
        the_broker = MyRedisBroker()
        queue_name = "AdderTask"

        async def run(self, a, b):
            """
            adds two numbers and stores the resut in a database
            """
            result = a + b
            DATABASE["result"] = result
            return result

    class ExampleView:
        def post(self, request):
            a = request["a"]
            b = request["b"]
            AdderTask().synchronous_delay(a=a, b=b)

| In the example above we have a view with one ``post`` method. When
  that method is called it queues a task that adds two numbers and then
  stores the result of that addition in a database.
| That task uses a broker(\ ``MyRedisBroker``) that is backed by redis.
| One way to write your tests would be;

.. code:: python


    # test_tasks.py

    from my_tasks import ExampleView
    from unittest import TestCase

    class TestExampleView(TestCase):
        def test_view(self):
            view = ExampleView()
            view.post(request={"a": 45, "b": 46})
            # do your asserts here

| The problem with the above approach is that this will require you to
  have an instance of redis running for that test to run succesfully.
| This may not be what you want. Ideally you do not want your tests be
  dependent on external services.
| ``wiji`` ships with an in-memory broker that you can use in your
  tests.
| So the test above can be re-written in this manner;

.. code:: python


    # test_tasks.py

    import asyncio
    from my_tasks import ExampleView, AdderTask, DATABASE
    from unittest import TestCase, mock

    class TestExampleView(TestCase):

        @staticmethod
        def _run(coro):
            """
            helper function that runs any coroutine in an event loop.
            see:: https://blog.miguelgrinberg.com/post/unit-testing-asyncio-code
            """
            loop = asyncio.get_event_loop()
            return loop.run_until_complete(coro)

        def test_view(self):
            with mock.patch.object(
                # ie, substitute the redis broker with an in-memory one during test runs
                AdderTask, "the_broker", wiji.broker.InMemoryBroker()
            ) as mock_broker:
                view = ExampleView()
                view.post(request={"a": 45, "b": 46})
                # do your asserts here

        def test_whole_flow(self):
            with mock.patch.object(
                AdderTask, "the_broker", wiji.broker.InMemoryBroker()
            ) as mock_broker:
                # 1. assert that the database is initially empty
                self.assertDictEqual(DATABASE, {})

                # 2. when `post` is called it will queue a task
                view = ExampleView()
                view.post(request={"a": 45, "b": 46})

                # 3. we need to run workers
                worker = wiji.Worker(the_task=AdderTask())
                self._run(worker.consume_tasks(TESTING=True))

                # 4. assert that database has been updated succesfully.
                self.assertDictEqual(DATABASE, {"result": 91})

.. |Codacy Badge| image:: https://api.codacy.com/project/badge/Grade/f0b4b7a07da24e90bdb7743d0e6b9240
   :target: https://www.codacy.com/app/komuw/wiji
.. |CircleCI| image:: https://circleci.com/gh/komuw/wiji.svg?style=svg
   :target: https://circleci.com/gh/komuw/wiji
.. |codecov| image:: https://codecov.io/gh/komuw/wiji/branch/master/graph/badge.svg
   :target: https://codecov.io/gh/komuw/wiji
.. |Code style: black| image:: https://img.shields.io/badge/code%20style-black-000000.svg
   :target: https://github.com/komuw/wiji


