# -*- coding: utf-8 -*-
"""
Calculate and plot length distribution of sequences (by nts)
"""

import os
import sys

import matplotlib.pyplot as plt
import numpy as np
# pylint: disable = E0401
from Bio import AlignIO
from scipy.interpolate import make_interp_spline  # , BSpline

X_MAX = 500


def process_maf(filepath):
    """
    Process a file in MAF format

    :param filepath:
    :return:
    """
    sizes = []
    for msa in AlignIO.parse(filepath, "maf"):
        # msa is of type <class 'Bio.Align.MultipleSeqAlignment'>
        for sr in msa:
            # sr is of type <class 'Bio.SeqRecord.SeqRecord'>
            sizes.append(sr.annotations['size'])
    return sizes


def process_rnaz_out(filepath):
    """
    Process RNAz output format

    :param filepath:
    :return:
    """
    sizes = []
    with open(filepath, "r") as fh:
        for line in fh:
            if line.startswith('>') and not line.startswith('>consensus'):
                x = line.split()
                # print(x)
                nts = x[2]
                sizes.append(nts)
    return sizes


def process_dat(filepath):
    """
    Process RNAz dat file format (generated by rnazCluster.pl

    :param filepath:
    :return:
    """
    sizes = []
    with open(filepath, "r") as fh:
        for line in fh:
            if line.startswith('locus'):
                x = line.split()
                start = int(x[2])
                end = int(x[3])
                length = end - start
                sizes.append(length)
    return sizes


def run(in_file, binz, out_file):
    """
    Just do it
    """
    _, file_extension = os.path.splitext(in_file)
    if file_extension == '.maf':
        sizes_ = process_maf(in_file)
    elif file_extension == '.out':
        sizes_ = process_rnaz_out(in_file)
    elif file_extension == '.dat':
        sizes_ = process_dat(in_file)
    else:
        raise Exception("Unsupported file type")

    plt.style.use('seaborn-white')
    data = np.array(sizes_)
    n, binz, _ = plt.hist(data, bins=binz, alpha=0.2, density=True)
    plt.grid(axis='y', alpha=0.5)
    X_MAX = 100  # AHAHHAHGHHGHHG
    plt.xlim([0, X_MAX])

    bin_centers = 0.5 * (binz[1:] + binz[:-1])

    if file_extension in ['.dat', '.out']:
        first_bin_center = max(2 * bin_centers[0] - bin_centers[1], 0)
        last_bin_center = min(2 * bin_centers[-1] - bin_centers[-2], X_MAX)
        bin_centers = np.insert(bin_centers, 0, first_bin_center)
        bin_centers = np.append(bin_centers, last_bin_center)
        n = np.insert(n, 0, 0)
        n = np.append(n, 0)
        x_new = np.linspace(bin_centers.min(),
                            bin_centers.max(),
                            300)  # 300 is # of points to make between min and max
        spl = make_interp_spline(bin_centers, n, k=3)  # BSpline object
        y_new = spl(x_new)
        plt.plot(x_new, y_new)
    else:
        plt.plot(bin_centers, n)

    plt.xlabel('length (nts)')
    plt.ylabel('frequency')
    plt.title('Length Distribution')
    plt.savefig(out_file)


if __name__ == '__main__':

    INFILE = sys.argv[1]
    BINS = sys.argv[2]
    try:
        binz = int(BINS)
    except ValueError:
        pass
    OUTFILE = sys.argv[3]

    run(INFILE, binz, OUTFILE)
