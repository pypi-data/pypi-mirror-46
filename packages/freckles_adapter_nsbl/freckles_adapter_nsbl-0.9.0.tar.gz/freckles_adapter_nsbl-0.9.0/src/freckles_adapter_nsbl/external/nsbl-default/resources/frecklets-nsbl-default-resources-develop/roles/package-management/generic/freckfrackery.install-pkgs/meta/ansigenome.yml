---
ansigenome_info:
  galaxy_id: ''

  travis: False
  status:
    name: beta

  synopsis: |
    An Ansible role to install a list of packages, platform-independent.

  usage: |

    As package names for the same application can be different for different platforms,
    the items in ``install_packages`` need to be able to reflect this. Depending on the
    package and the intended target platforms, this configuration can be more or less
    involved.

    In the most complete case, a package item looks like this:

    ```YAML
    install_packages:
      - name: <package_name>
        pkg_mgr: <package manager>
        become: <pkg_mgn_become>
        pkgs:
          <platform_identifier_1>: <pkg_name>
          <platform_identifier_2>: <pkg_name>
          <platform_identifier_3>: <pkg_name>
          ...
          default: <pkg_name>
    ```

    'default' is an optional key that can be used as a fallback for when nothing else matches. If the 'default'
    key is not specified, the 'name' key will be used.

    If any of the platform_identifier keys has the string 'omit' as value, no package will be installed if
    it is matched.

    The 'become' key can usually be omitted, as the 'install' module knows good defaults for each of the
    package managers. There are some cases where specifing might make sense though (for example with 'pip').

    You can check the verbose Ansible log output of a test run for all potential platform identifiers for the current platform.

    Alternatively, if you use a package manager where the package name is the same on all platforms, you can use this
    role to specify lists of lists of packages, where each sub-list has the same metadata (e.g. package manager):

    ```YAML
    install_packages:
      - name: <name of package group>
        pkg_mgr: <pkg_mgr_1>
        pkgs:
          - <pkg_name_1>
          - <pkg_name_2>
          ...
      - name: <name of package group 2>
        pkg_mgr: <pkg_mgr_2>
        pkgs:
          - <pkg_name_3>
          - <pkg_name_4>
    ```

    ##### Platform identifiers

    Platform identifiers will be matched from the most to least specific, first match will win:

    - full distribution version string
    - full release string
    - distribution major string
    - distribution (Debian, Ubuntu, RedHat, CentOS, Darwin, ...)
    - os family (Debian, RedHat, Darwin)
    - platform (Linux, Darwin, Windows, Java, ...)

    Matching happens case insensitive.

    ##### Supported package managers

    ###### apt

    TODO

    ###### yum

    TODO

    ###### homebrew

    TODO

    ###### nix

    TODO

    ###### conda

    TODO

    ###### pip

    TODO

    ###### git

    TODO

    ###### unarchive

    TODO

    ###### vagrant

    TODO


    Please check the examples below for more details.

  examples:
    - title: Same package name on all platforms, short form
      desc: |
        In the most simple case, the packages to install have the same name on each of
        the intended target platforms. If this is the case, each package item can be
        the package name as a string.
      task_vars: |
        install_packages:
          - zile
          - top
    - title: Same package name on all platforms, long form
      desc: |
        Same scenario as above, just using the full form to describe it:
      task_vars: |
        install_packages:
          - name: zile
          - name: top
    - title: A package with different package names on different platforms
      desc: |
        This isn't an uncommon occurence for the more 'basic', underlaying dependency
        packages. For example Debian and RedHat have different post-fixes for their
        development packages (``<package>-dev`` and ``<package>-dvel``).

        Matching happens case independent. If the platform is neither Debian nor RedHat based, nothing will be
        installed. Ubuntu would still match, as it is Debian based for example.
      task_vars: |
        install_packages:
          - name: python-dev
            pkg_mgr: auto    # can be skipped, as it's the default
            pkgs:
              debian: python-dev
              redhat: python-devel
              default: omit
    - title: Mixed package names, some the same, some different on different platforms, long as well as short form.
      desc: |
        It's easy to mix both ways of describing your packages:
      task_vars: |
        install_packages:
          - top
          - name: python-dev
            pkgs:
              Debian: python-dev
              RedHat: python-devel
    - title: Different package managers
      desc: |
        A package list can also contain packages that will be installed by different package managers  ('auto' refers to the default system package manager):
      task_vars: |
        install_packages:
          - name: htop
            pkg_mgr: nix
          - name: cookiecutter
            pkg_mgr: pip
          - name: zile
            pkg_mgr: auto
    - title: Different package managers, multiple packages per package manager.
      desc: |
        Same as the above example, just using package groups instead of single packages.
      task_vars: |
        install_packages:
          - name: system utils
            pkg_mgr: nix
            pkgs:
              - htop
              - netcat
          - name: python utils
            pkg_mgr: pip
            virtualenv: ~/.virtualenvs/global_virtualenv
            pkgs:
              - cookiecutter
              - thefuck


  custom: |
    ### Requirements

    This role needs:
      - the [freckfrackery.install-pkg-mgrs](https://gitlab.com/freckfrackery/freckfrackery.install-pkg-mgrs) Ansible role
      - the ``install`` [module](https://gitlab.com/nsbl/nsbl-plugins/blob/master/library/install.py) and [action plugin](https://gitlab.com/nsbl/nsbl-plugins/blob/master/action_plugins/install.py)
