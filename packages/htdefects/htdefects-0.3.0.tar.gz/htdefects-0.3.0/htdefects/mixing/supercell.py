# -*- coding: utf-8 -*-

"""Helper functions to construct/handle mixing supercells."""

import copy
import numpy as np


class SupercellError(Exception):
    """Base class to handle errors associated with supercell generation."""
    pass


def get_supercell_for_mixing(structure, min_image_dist=12, verbosity=0):
    """Generates a supercell with a specified minimum image distance.

    Parameters
    ----------

    structure: :class:`dftinpgen.atoms.Structure`
        Base structure with which to construct supercell.

    min_image_dist: float, optional
        Minimum distance between periodic images in Angstrom.

        Defaults to 12 Angstrom.

    verbosity: int, optional
        Standard output verbosity.

        Defaults to 0 (no standard output).

    Returns
    -------

    :class:`dftinpgen.atoms.Structure`
        Supercell with the specified minimum image distance.

    """
    try:
        supercell = supercell_from_ase(structure=structure,
                                       min_image_dist=min_image_dist,
                                       verbosity=verbosity)
    except SupercellError:
        supercell = supercell_by_translation(structure=structure,
                                             min_image_dist=min_image_dist,
                                             verbosity=verbosity)
    return supercell


def supercell_by_translation(structure, min_image_dist=12, verbosity=0):
    """Generates a supercell with a specified minimum image distance.

    A supercell of `structure` is generated by simply translating it in X,
    Y, Z directions such that the minimum distance between periodic images
    is larger than `min_image_dist`.

    Parameters
    ----------

    structure: :class:`dftinpgen.atoms.Structure`
        Base structure with which to construct supercell.

    min_image_dist: float, optional
        Minimum distance between periodic images in Angstrom.

        Defaults to 12 Angstrom.

    verbosity: int, optional
        Standard output verbosity.

        Defaults to 0 (no standard output).

    Returns
    -------

     :class:`dftinpgen.atoms.Structure`
        Supercell with the specified minimum image distance.

    """
    supercell = copy.deepcopy(structure)

    # translate the structure in x, y, z directions depending on the minimum
    # image distance specified
    lat_vec_mags = [np.linalg.norm(lv) for lv in structure.cell]
    translation_factors = [int(np.ceil(min_image_dist/lvg)) for lvg in
                           lat_vec_mags]
    supercell.supa('{} {} {}'.format(*translation_factors))
    image_dist = calc_min_image_dist(supercell)

    if verbosity:
        print('Supercell dimensions: [{} {} {}]'.format(*translation_factors))
        print('Image separation = {:0.2f} Angstrom'.format(image_dist))

    return supercell


def get_natoms_bounds_for_ase_supercell(structure, min_image_dist=12):
    """Gets lower and upper bounds for the number of atoms in the supercell
    generated with `ase`.

    The lower bound is estimated using a perfectly simple-cubic supercell
    as follows. Let us assume that the supercell were a perfect cube with
    sides equal to "min_image_dist". Then it would contain N cells of the
    specified structure, where N = min_image_dist**3/volume of structure.
    Since N is not guaranteed to be an integer, the lower bound for the
    number of atoms is simply the floor of the floating point number N
    (considering the floor also takes care of any numerical noise in N).

    The upper bound also follows from similar arguments. At worst,
    it should be possible to construct the supercell with 2*2*2*N atoms in
    it. Here, considering the ceiling of N avoids issues with floating point
    arithmetic accuracy issues, if any.

    Parameters
    ----------

    structure: :class:`dftinpgen.atoms.Structure`
        Base structure with which to construct supercell.

    min_image_dist: float, optional
        Minimum distance between periodic images in Angstrom.

        Defaults to 12 Angstrom.

    Returns
    -------

    (tuple(int, int))
        Lower and upper bounds for the number of atoms in the supercell.

    """
    ideal_sc_volume = min_image_dist**3
    uc_volume = structure.volume
    sc_uc_scale = ideal_sc_volume/uc_volume
    low = (int(np.ceil(sc_uc_scale)) - 1)*structure.totalnatoms
    high = min(512, 8*int(np.ceil(sc_uc_scale))*structure.totalnatoms)
    return low, high


def calc_min_image_dist(structure):
    """Calculates the minimum distance between periodic images of structure.

    Parameters
    ----------

    structure: :class:`dftinpgen.atoms.Structure`
        Base structure in which the image distance has to be calculated.

    Returns
    -------

    float
        Minimum distance between periodic images in Angstrom.

    """
    translations = [
        [0, 0, 1],
        [0, 1, 0],
        [1, 0, 0],
        [0, 1, 1],
        [1, 0, 1],
        [1, 1, 0],
        [1, 1, 1]
    ]
    image_distances = []
    for t in translations:
        image_distance = np.linalg.norm(t[0]*structure.a1
                                        + t[1]*structure.a2
                                        + t[2]*structure.a3)
        image_distances.append(image_distance)
    return min(image_distances)


def supercell_from_ase(structure, min_image_dist=12, verbosity=0):
    """Generates a cubic-like supercell with a specified minimum image
    distance using the `ase` package.

    Parameters
    ----------

    structure: :class:`dftinpgen.atoms.Structure`
        Base structure with which to construct supercell.

    min_image_dist: float, optional
        Minimum distance between periodic images in Angstrom.

        Defaults to 12 Angstrom.

    verbosity: int, optional
        Standard output verbosity.

        Defaults to 0 (no standard output).

    Returns
    -------

    :class:`dftinpgen.atoms.Structure`
        Supercell with the specified minimum image distance.

    Raises
    ------

    SupercellError if unable to generate a suitable supercell.

    """

    low, high = get_natoms_bounds_for_ase_supercell(
            structure=structure,
            min_image_dist=min_image_dist
    )

    found_sc = False
    for natoms in range(low, high, structure.totalnatoms):
        supercell = copy.deepcopy(structure)
        supercell.ase_supa(natoms)
        image_dist = calc_min_image_dist(supercell)
        if image_dist >= min_image_dist:
            found_sc = True
            break

    if not found_sc:
        error_msg = 'Unable to find suitable supercell via `ase`'
        raise SupercellError(error_msg)

    if verbosity:
        print('Successfully generated sc-like supercell using `ase`.')
        print('  Defect separation = {:0.2f} Angstrom'.format(image_dist))
        print('  Number of atoms in supercell = {}'.format(natoms))

    return supercell
